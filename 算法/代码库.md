

# 技巧

${O(n^2)}$可以解决10^4规模



一般 ACM 或者笔试题的时间限制是 1 秒或 2 秒。  
在这种情况下，C++ 代码中的操作次数控制在 $10^7 \sim 10^8$ 为最佳。

下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：

1.  $n \le 30$, 指数级别, dfs + 剪枝，状态压缩 dp
2.  $n \le 100$ => $O(n^3)$，floyd，dp，高斯消元
3.  $n \le 1000$ => $O(n^2)$，$O(n^2logn)$，dp，二分，朴素版 Dijkstra、朴素版 Prim、Bellman-Ford
4.  $n \le 10000$ => $O(n * \sqrt n)$，块状链表、分块、莫队
5.  $n \le 100000$ => $O(nlogn)$ => 各种 sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ 分治、整体二分、后缀数组、树链剖分、动态树
6.  $n \le 1000000$ => $O(n)$, 以及常数较小的 $O(nlogn)$ 算法 => 单调队列、 hash、双指针扫描、并查集，kmp、AC 自动机，常数比较小的 $O(nlogn)$ 的做法：sort、树状数组、heap、dijkstra、spfa
7.  $n \le 10000000$ => $O(n)$，双指针扫描、kmp、AC 自动机、线性筛素数
8.  $n \le 10^9$ => $O(\sqrt n)$，判断质数
9.  $n \le 10^{18}$ => $O(logn)$，最大公约数，快速幂，数位 DP
10.  $n \le 10^{1000}$ => $O((logn)^2)$，高精度加减乘除
11.  $n \le 10^{100000}$ => $O(logk \times loglogk)，k 表示位数 $，高精度加减、FFT/NTT

# 常用函数与STL标准模板库

### STL实现Ugly Numbers

```C++
\#include <iostream>

\#include <queue>

 

/*

 \* Ugly Numbers

 \* Ugly numbers are numbers whose only prime factors are 2, 3 or 5.

 \* 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ...

 */

 

typedef std::pair<unsigned long, int> node_type;

 

int main(int argc, const char * argv[])

{

  unsigned long result[1502];

  std::priority_queue<node_type, std::vector<node_type>, std::greater<node_type>> Q;

  Q.push(std::make_pair(1, 2));

  for (int i = 0; i < 1500; i++)

  {

    node_type node = Q.top();

    Q.pop();

    switch (node.second)

    {

      case 2:

        Q.push(std::make_pair(node.first * 2, 2));

      case 3:

        Q.push(std::make_pair(node.first * 3, 3));

      case 5:

        Q.push(std::make_pair(node.first * 5, 5));

    }

    result[i] = node.first;

  }

 

  int n;

  std::cin >> n;

  while (n > 0)

  {

   std::cout << result[n - 1] << '\n';

    std::cin >> n;

  }

 

  return 0;

}
```

### STL-pair

```C++
STL的<`utility`>头文件中描述了一个看上去非常简单的模版类pair，用来表示一个二元组或元素对，并提供了按照字典序对元素对进行大小比较运算符模版函数。 
 Example，想要定义一个对象表示一个平面坐标点，则可以：

pair<double, double> p;

cin >> p.first >> p.second;
```



### STL-set的基本操作

```C++
s.begin()    // 返回指向第一个元素的迭代器

s.clear()    // 清除所有元素

s.count()    // 返回某个值元素的个数

s.empty()    // 如果集合为空，返回true(真）

s.end()     // 返回指向最后一个元素之后的迭代器，不是最后一个元素

s.equal_range() // 返回集合中与给定值相等的上下限的两个迭代器

s.erase()    // 删除集合中的元素

s.find()    // 返回一个指向被查找到元素的迭代器

s.get_allocator()  // 返回集合的分配器

s.insert()   // 在集合中插入元素

s.lower_bound() // 返回指向大于（或等于）某值的第一个元素的迭代器

s.key_comp()  // 返回一个用于元素间值比较的函数

s.max_size()  // 返回集合能容纳的元素的最大限值

s.rbegin()   // 返回指向集合中最后一个元素的反向迭代器

s.rend()    // 返回指向集合中第一个元素的反向迭代器

s.size()    // 集合中元素的数目

s.swap()    // 交换两个集合变量

s.upper_bound() // 返回大于某个值元素的迭代器

s.value_comp() // 返回一个用于比较元素间的值的函数

 

多重集合与集合的区别在于集合中不能存在相同元素，而多重集合中可以存在。

multiset<int> s;

multiset<double> ss;

multiset和set的基本操作相似，需要注意的是，集合的`count()`能返回0（无）或者1（有），而多重集合是有多少个返回多少个
```



### STL-vector

```C++
vector<int> s;   

// 定义一个空的vector对象，存储的是int类型的元素

vector<int> s(n);  

// 定义一个含有n个int元素的vector对象

vector<int> s(first, last); 

// 定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值

 

Vector的基本操作

s[i]        // 直接以下标方式访问容器中的元素

s.front()      // 返回首元素

s.back()      // 返回尾元素

s.push_back(x)   // 向表尾插入元素x

s.size()      // 返回表长

s.empty()      // 表为空时，返回真，否则返回假

s.pop_back()    // 删除表尾元素

s.begin()      // 返回指向首元素的随机存取迭代器

s.end()       // 返回指向尾元素的下一个位置的随机存取迭代器

s.insert(it, val)  // 向迭代器it指向的元素前插入新元素val

s.insert(it, n, val)// 向迭代器it指向的元素前插入n个新元素val

s.insert(it, first, last)  

// 将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面

s.erase(it)     // 删除由迭代器it所指向的元素

s.erase(first, last)// 删除由迭代器first和last所指定的序列[first, last)

s.reserve(n)    // 预分配缓冲空间，使存储空间至少可容纳n个元素

s.resize(n)     // 改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间

s.resize(n, val)  // 改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），val将填满扩展出的空间

s.clear()      // 删除容器中的所有元素

s.swap(v)      // 将s与另一个vector对象进行交换

s.assign(first, last)

// 将序列替换成由迭代器first和last所指定的序列[first, last)，[first, last)不能是原序列中的一部分

 

// 要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小

// 另外，vector还有其他的一些操作，如反转、取反等，不再一一列举

// vector上还定义了序列之间的比较操作运算符（>、<、>=、<=、==、!=），可以按照字典序比较两个序列。
```



### STL-stack

```C++
Stack的基本操作：

s.push(x); // 入栈

s.pop();  // 出栈

s.top();  // 访问栈顶

s.empty(); // 当栈空时，返回true

s.size();  // 访问栈中元素个数
```

### STL-queue

```C++
Queue的基本操作：

q.push(x); // 入队列

q.pop();  // 出队列

q.front(); // 访问队首元素

q.back();  // 访问队尾元素

q.empty(); // 判断队列是否为空

q.size();  // 访问队列中的元素个数

 

优先队列：

priority_queue<int> q;

priority_queue<pair<int, int> > qq;         // 注意在两个尖括号之间一定要留空格，防止误判

priority_queue<int, vector<int>, greater<int> > qqq;// 定义小的先出队列

优先队列的基本操作：

q.empty()   // 如果队列为空，则返回true，否则返回false

q.size()   // 返回队列中元素的个数

q.pop()    // 删除队首元素，但不返回其值

q.top()    // 返回具有最高优先级的元素值，但不删除该元素

q.push(item) // 在基于优先级的适当位置插入新元素

\#include <iostream>

\#include <queue>

using namespace std;

class T

{

public:

  int x, y, z;

  T(int a, int b, int c) : x(a), y(b), z(c) {}

};

bool operator < (const T &tOne, const T &tTwo)

{

  return tOne.z < tTwo.z; // 按照z的顺序来决定tOne和tTwo的顺序

}

int main()

{

  priority_queue<T> q;

  q.push(T(4, 4, 3));

  q.push(T(2, 2, 5));

  q.push(T(1, 5, 4));

  q.push(T(3, 3, 6));

 

  while (!q.empty())

  {

     T t = q.top();

     q.pop();

     cout << t.x << " " << t.y << " " << t.z << '\n';

  }

  return 0;

}
```



### STL-map

```C++
/* 向map中插入元素 */

m[key] = value; // [key]操作是map很有特色的操作,如果在map中存在键值为key的元素对, 则返回该元素对的值域部分,否则将会创建一个键值为key的元素对,值域为默认值。所以可以用该操作向map中插入元素对或修改已经存在的元素对的值域部分。

m.insert(make_pair(key, value));  // 也可以直接调用insert方法插入元素对,insert操作会返回一个pair,当map中没有与key相匹配的键值时,其first是指向插入元素对的迭代器,其second为true;若map中已经存在与key相等的键值时,其first是指向该元素对的迭代器,second为false。

 

/* 查找元素 */

int i = m[key]; // 要注意的是,当与该键值相匹配的元素对不存在时,会创建键值为key（当另一个元素是整形时，m[key]=0）的元素对。

map<string, int>::iterator it = m.find(key);  // 如果map中存在与key相匹配的键值时,find操作将返回指向该元素对的迭代器,否则,返回的迭代器等于map的end()(参见vector中提到的begin()和end()操作)。

 

/* 删除元素 */

m.erase(key);  // 删除与指定key键值相匹配的元素对,并返回被删除的元素的个数。

m.erase(it);  // 删除由迭代器it所指定的元素对,并返回指向下一个元素对的迭代器。

 

/* 其他操作 */

m.size();    // 返回元素个数

m.empty();   // 判断是否为空

m.clear();   // 清空所有元素

 
```



**二维map应用：**

```C++
map<string,map<string,int> > mp;
map<string,map<string,int> >::iterator it;
map<string,int>::iterator it2;
for(it=mp.begin();it!=mp.end();it++){
            cout<<it->first<<endl;
            for(it2=it->second.begin();it2!=it->second.end();it2++){
                cout<<"   |----"<<it2->first<<"("<<it2->second<<")"<<endl;
            }
        }
```

 

### STL-bitset

```C++
在 STLSTL 的头文件中 <bitset><bitset> 中定义了模版类 bitsetbitset，用来方便地管理一系列的 bitbit 位的类。bitsetbitset 除了可以访问指定下标的 bitbit 位以外，还可以把它们作为一个整数来进行某些统计。

 

bitsetbitset 模板类需要一个模版参数，用来明确指定含有多少位

 

定义bitset对象的示例代码：

const int MAXN = 32;

 

bitset<MAXN> bt;      // bt 包括 MAXN 位，下标 0 ~ MAXN - 1，默认初始化为 0

bitset<MAXN> bt1(0xf);   // 0xf 表示十六进制数 f，对应二进制 1111，将 bt1 低 4 位初始化为 1

bitset<MAXN> bt2(012);   // 012 表示八进制数 12，对应二进制 1010，即将 bt2 低 4 位初始化为 1010

bitset<MAXN> bt3("1010");  // 将 bt3 低 4 位初始化为 1010

bitset<MAXN> bt4(s, pos, n);// 将 01 字符串 s 的 pos 位开始的 n 位初始化 bt4

 

bitset的基本操作：

bt.any()    // bt 中是否存在置为 1 的二进制位？

bt.none()    // bt 中不存在置为 1 的二进制位吗？

bt.count()   // bt 中置为 1 的二进制位的个数

bt.size()    // bt 中二进制位的个数

bt[pos]     // 访问 bt 中在 pos 处的二进制位

bt.test(pos)  // bt 中在 pos 处的二进制位是否为 1

bt.set()    // 把 bt 中所有二进制位都置为 1

bt.set(pos)   // 把 bt 中在 pos 处的二进制位置为 1

bt.reset()   // 把 bt 中所有二进制位都置为 0

bt.reset(pos)  // 把 bt 中在pos处的二进制位置为0

bt.flip()    // 把 bt 中所有二进制位逐位取反

bt.flip(pos)  // 把 bt 中在 pos 处的二进制位取反

bt[pos].flip() // 同上

bt.to_ulong()  // 用 bt 中同样的二进制位返回一个 unsigned long 值

os << bt    // 把 bt 中的位集输出到 os 流
```



### STL-iterator迭代器特别输出

```C++
\#include <iostream>

\#include <vector>

using namespace std;

int main()

{

  vector<int> s;

  s.push_back(1);

  s.push_back(2);

  s.push_back(3);

  copy(s.begin(), s.end(), ostream_iterator<int> (cout, " "));

  cout << '\n';

  return 0;

}
```



这段代码中的copy就是STL中定义的一个模版函数，copy(s.begin(), s.end(), ostream_iterator<int>(cout, ” “));的意思是将由s.begin()至s.end()（不含s.end()）所指定的序列复制到标准输出流out中，用” “作为每个元素的间隔。也就是说，这句话的作用其实就是将表中的所有内容依次输出

### STL-algorithm

```C++
min_element/max_element找出容器中的最小/最大值

\#include <iostream>

\#include <vector>

\#include <algorithm>

using namespace std;

int main()

{

  vector<int> L;

  for (int i=0; i<10; i++) 

  {

    L.push_back(i);

  }

  vector<int>::iterator min_it = min_element(L.begin(), L.end());

  vector<int>::iterator max_it = max_element(L.begin(), L.end());

  cout << "Min is " << *min_it << endl;

  cout << "Max is " << *max_it << endl;

  return 0;

}

 

Copy:

// 将vOne的前三个元素复制到vTwo的中间（覆盖掉原来数据）

  copy(vOne.begin(), vOne.begin() + 3, vTwo.begin() + 4);

// 在vTwo内部进行复制，注意参数2表示结束位置，结束位置不参与复制

  copy(vTwo.begin() + 4, vTwo.begin() + 7, vTwo.begin() + 2);
```



 

### 输出一个数的2 8 10 16进制（模板）

```C++
\#include <bitset>

\#include <iostream>

using namespace std;

int main()

{

  cout << "36的8进制:" << std::oct << 36 << endl;

  cout << "36的10进制" << std::dec << 36 << endl;

  cout << "36的16进制:" << std::hex << 36 << endl;

  cout << "36的2进制: " << bitset<8>(36) << endl;

  return 0;

}

 
```



### 10进制与26进制相互转化

```C++
\#include<iostream>

\#include <algorithm>

using namespace std;

int main(){

  long long ans=0;

   string s;

   cin>>s;

 

   int len=s.size();

   for(int i=0,j=1;i<s.size();i++,j*=26){

      ans+=(int)(s[len-i-1]-65)*j;

   }

   cout<<ans<<endl;   //26进制转十进制

 

   string str="";

   //ans=817;

   while(ans>0){

      int m=ans%26;

      if(m==0) m=0;

      str+=(char)(m+65);

      ans=(ans-m)/26;

   }

   reverse(str.begin(),str.end()); //反序

   cout<<str<<endl; //  十进制转26进制

   return 0;

}
```



 

### 26进制下的大数加法

```C++
常用函数与STL标准模板库
STL实现Ugly Numbers
#include <iostream>
#include <queue>

/*
 * Ugly Numbers
 * Ugly numbers are numbers whose only prime factors are 2, 3 or 5.
 * 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ...
 */

typedef std::pair<unsigned long, int> node_type;

int main(int argc, const char * argv[])
{
    unsigned long result[1502];
    std::priority_queue<node_type, std::vector<node_type>, std::greater<node_type>> Q;
    Q.push(std::make_pair(1, 2));
    for (int i = 0; i < 1500; i++)
    {
        node_type node = Q.top();
        Q.pop();
        switch (node.second)
        {
            case 2:
                Q.push(std::make_pair(node.first * 2, 2));
            case 3:
                Q.push(std::make_pair(node.first * 3, 3));
            case 5:
                Q.push(std::make_pair(node.first * 5, 5));
        }
        result[i] = node.first;
    }

    int n;
    std::cin >> n;
    while (n > 0)
    {
        std::cout << result[n - 1] << '\n';
        std::cin >> n;
    }

    return 0;
}

STL-pair
STL的<utility>头文件中描述了一个看上去非常简单的模版类pair，用来表示一个二元组或元素对，并提供了按照字典序对元素对进行大小比较运算符模版函数。 
Example，想要定义一个对象表示一个平面坐标点，则可以：
pair<double, double> p;
cin >> p.first >> p.second;
STL-set的基本操作
s.begin()       //  返回指向第一个元素的迭代器
s.clear()       //  清除所有元素
s.count()       //  返回某个值元素的个数
s.empty()       //  如果集合为空，返回true(真）
s.end()         //  返回指向最后一个元素之后的迭代器，不是最后一个元素
s.equal_range() //  返回集合中与给定值相等的上下限的两个迭代器
s.erase()       //  删除集合中的元素
s.find()        //  返回一个指向被查找到元素的迭代器
s.get_allocator()   //  返回集合的分配器
s.insert()      //  在集合中插入元素
s.lower_bound() //  返回指向大于（或等于）某值的第一个元素的迭代器
s.key_comp()    //  返回一个用于元素间值比较的函数
s.max_size()    //  返回集合能容纳的元素的最大限值
s.rbegin()      //  返回指向集合中最后一个元素的反向迭代器
s.rend()        //  返回指向集合中第一个元素的反向迭代器
s.size()        //  集合中元素的数目
s.swap()        //  交换两个集合变量
s.upper_bound() //  返回大于某个值元素的迭代器
s.value_comp()  //  返回一个用于比较元素间的值的函数

多重集合与集合的区别在于集合中不能存在相同元素，而多重集合中可以存在。
multiset<int> s;
multiset<double> ss;
multiset和set的基本操作相似，需要注意的是，集合的count()能返回0（无）或者1（有），而多重集合是有多少个返回多少个
STL-vector
vector<int> s;      
//  定义一个空的vector对象，存储的是int类型的元素
vector<int> s(n);   
//  定义一个含有n个int元素的vector对象
vector<int> s(first, last); 
//  定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值

Vector的基本操作
s[i]                //  直接以下标方式访问容器中的元素
s.front()           //  返回首元素
s.back()            //  返回尾元素
s.push_back(x)      //  向表尾插入元素x
s.size()            //  返回表长
s.empty()           //  表为空时，返回真，否则返回假
s.pop_back()        //  删除表尾元素
s.begin()           //  返回指向首元素的随机存取迭代器
s.end()             //  返回指向尾元素的下一个位置的随机存取迭代器
s.insert(it, val)   //  向迭代器it指向的元素前插入新元素val
s.insert(it, n, val)//  向迭代器it指向的元素前插入n个新元素val
s.insert(it, first, last)   
//  将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面
s.erase(it)         //  删除由迭代器it所指向的元素
s.erase(first, last)//  删除由迭代器first和last所指定的序列[first, last)
s.reserve(n)        //  预分配缓冲空间，使存储空间至少可容纳n个元素
s.resize(n)         //  改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间
s.resize(n, val)    //  改变序列长度，超出的元素将会全部被删除，如果序列需要扩展（原空间小于n），val将填满扩展出的空间
s.clear()           //  删除容器中的所有元素
s.swap(v)           //  将s与另一个vector对象进行交换
s.assign(first, last)
//  将序列替换成由迭代器first和last所指定的序列[first, last)，[first, last)不能是原序列中的一部分

//  要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小
//  另外，vector还有其他的一些操作，如反转、取反等，不再一一列举
//  vector上还定义了序列之间的比较操作运算符（>、<、>=、<=、==、!=），可以按照字典序比较两个序列。
STL-stack
Stack的基本操作：
s.push(x);  //  入栈
s.pop();    //  出栈
s.top();    //  访问栈顶
s.empty();  //  当栈空时，返回true
s.size();   //  访问栈中元素个数
STL-queue
Queue的基本操作：
q.push(x);  //  入队列
q.pop();    //  出队列
q.front();  //  访问队首元素
q.back();   //  访问队尾元素
q.empty();  //  判断队列是否为空
q.size();   //  访问队列中的元素个数

优先队列：
priority_queue<int> q;
priority_queue<pair<int, int> > qq;                 //  注意在两个尖括号之间一定要留空格，防止误判
priority_queue<int, vector<int>, greater<int> > qqq;//  定义小的先出队列
优先队列的基本操作：
q.empty()     //  如果队列为空，则返回true，否则返回false
q.size()      //  返回队列中元素的个数
q.pop()       //  删除队首元素，但不返回其值
q.top()       //  返回具有最高优先级的元素值，但不删除该元素
q.push(item)  //  在基于优先级的适当位置插入新元素
#include <iostream>
#include <queue>
using namespace std;
class T
{
public:
    int x, y, z;
    T(int a, int b, int c) : x(a), y(b), z(c) {}
};
bool operator < (const T &tOne, const T &tTwo)
{
    return tOne.z < tTwo.z;  //  按照z的顺序来决定tOne和tTwo的顺序
}
int main()
{
    priority_queue<T> q;
    q.push(T(4, 4, 3));
    q.push(T(2, 2, 5));
    q.push(T(1, 5, 4));
    q.push(T(3, 3, 6));

    while (!q.empty())
    {
        T t = q.top();
        q.pop();
        cout << t.x << " " << t.y << " " << t.z << '\n';
    }
    return 0;
}
STL-map
/*  向map中插入元素  */
m[key] = value; //  [key]操作是map很有特色的操作,如果在map中存在键值为key的元素对, 则返回该元素对的值域部分,否则将会创建一个键值为key的元素对,值域为默认值。所以可以用该操作向map中插入元素对或修改已经存在的元素对的值域部分。
m.insert(make_pair(key, value));    //  也可以直接调用insert方法插入元素对,insert操作会返回一个pair,当map中没有与key相匹配的键值时,其first是指向插入元素对的迭代器,其second为true;若map中已经存在与key相等的键值时,其first是指向该元素对的迭代器,second为false。

/*  查找元素  */
int i = m[key]; //  要注意的是,当与该键值相匹配的元素对不存在时,会创建键值为key（当另一个元素是整形时，m[key]=0）的元素对。
map<string, int>::iterator it = m.find(key);    //  如果map中存在与key相匹配的键值时,find操作将返回指向该元素对的迭代器,否则,返回的迭代器等于map的end()(参见vector中提到的begin()和end()操作)。

/*  删除元素  */
m.erase(key);   //  删除与指定key键值相匹配的元素对,并返回被删除的元素的个数。
m.erase(it);    //  删除由迭代器it所指定的元素对,并返回指向下一个元素对的迭代器。

/*  其他操作  */
m.size();       //  返回元素个数
m.empty();      //  判断是否为空
m.clear();      //  清空所有元素

二维map应用：
map<string,map<string,int> > mp;
map<string,map<string,int> >::iterator it;
map<string,int>::iterator it2;
for(it=mp.begin();it!=mp.end();it++){
            cout<<it->first<<endl;
            for(it2=it->second.begin();it2!=it->second.end();it2++){
                cout<<"   |----"<<it2->first<<"("<<it2->second<<")"<<endl;
            }
        }

STL-bitset
在 STLSTL 的头文件中 <bitset><bitset> 中定义了模版类 bitsetbitset，用来方便地管理一系列的 bitbit 位的类。bitsetbitset 除了可以访问指定下标的 bitbit 位以外，还可以把它们作为一个整数来进行某些统计。

bitsetbitset 模板类需要一个模版参数，用来明确指定含有多少位

定义bitset对象的示例代码：
const int MAXN = 32;

bitset<MAXN> bt;            //  bt 包括 MAXN 位，下标 0 ~ MAXN - 1，默认初始化为 0
bitset<MAXN> bt1(0xf);      //  0xf 表示十六进制数 f，对应二进制 1111，将 bt1 低 4 位初始化为 1
bitset<MAXN> bt2(012);      //  012 表示八进制数 12，对应二进制 1010，即将 bt2 低 4 位初始化为 1010
bitset<MAXN> bt3("1010");   //  将 bt3 低 4 位初始化为 1010
bitset<MAXN> bt4(s, pos, n);//  将 01 字符串 s 的 pos 位开始的 n 位初始化 bt4

bitset的基本操作：
bt.any()        //  bt 中是否存在置为 1 的二进制位？
bt.none()       //  bt 中不存在置为 1 的二进制位吗？
bt.count()      //  bt 中置为 1 的二进制位的个数
bt.size()       //  bt 中二进制位的个数
bt[pos]         //  访问 bt 中在 pos 处的二进制位
bt.test(pos)    //  bt 中在 pos 处的二进制位是否为 1
bt.set()        //  把 bt 中所有二进制位都置为 1
bt.set(pos)     //  把 bt 中在 pos 处的二进制位置为 1
bt.reset()      //  把 bt 中所有二进制位都置为 0
bt.reset(pos)   //  把 bt 中在pos处的二进制位置为0
bt.flip()       //  把 bt 中所有二进制位逐位取反
bt.flip(pos)    //  把 bt 中在 pos 处的二进制位取反
bt[pos].flip()  //  同上
bt.to_ulong()   //  用 bt 中同样的二进制位返回一个 unsigned long 值
os << bt        //  把 bt 中的位集输出到 os 流
STL-iterator迭代器特别输出
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    vector<int> s;
    s.push_back(1);
    s.push_back(2);
    s.push_back(3);
    copy(s.begin(), s.end(), ostream_iterator<int> (cout, " "));
    cout << '\n';
    return 0;
}
这段代码中的copy就是STL中定义的一个模版函数，copy(s.begin(), s.end(), ostream_iterator<int>(cout, ” “));的意思是将由s.begin()至s.end()（不含s.end()）所指定的序列复制到标准输出流out中，用” “作为每个元素的间隔。也就是说，这句话的作用其实就是将表中的所有内容依次输出
STL-algorithm
min_element/max_element找出容器中的最小/最大值
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    vector<int> L;
    for (int i=0; i<10; i++) 
    {
        L.push_back(i);
    }
    vector<int>::iterator min_it = min_element(L.begin(), L.end());
    vector<int>::iterator max_it = max_element(L.begin(), L.end());
    cout << "Min is " << *min_it << endl;
    cout << "Max is " << *max_it << endl;
    return 0;
}

Copy:
//  将vOne的前三个元素复制到vTwo的中间（覆盖掉原来数据）
    copy(vOne.begin(), vOne.begin() + 3, vTwo.begin() + 4);
//  在vTwo内部进行复制，注意参数2表示结束位置，结束位置不参与复制
    copy(vTwo.begin() + 4, vTwo.begin() + 7, vTwo.begin() + 2);

输出一个数的2 8 10 16进制（模板）
#include <bitset>
#include <iostream>
using namespace std;
int main()
{
    cout << "36的8进制:" << std::oct << 36 << endl;
    cout << "36的10进制" << std::dec << 36 << endl;
    cout << "36的16进制:" << std::hex << 36 << endl;
    cout << "36的2进制: " << bitset<8>(36) << endl;
    return 0;
}

10进制与26进制相互转化
#include<iostream>
#include <algorithm>
using namespace std;

int main(){
	long long ans=0;
	string s;
	cin>>s;

	int len=s.size();
	for(int i=0,j=1;i<s.size();i++,j*=26){
		ans+=(int)(s[len-i-1]-65)*j;
	}
	cout<<ans<<endl;	//26进制转十进制

	string str="";
	//ans=817;
	while(ans>0){
		int m=ans%26;
		if(m==0) m=0;
		str+=(char)(m+65);
		ans=(ans-m)/26;
	}
	reverse(str.begin(),str.end());	//反序
	cout<<str<<endl;	//	十进制转26进制
	return 0;
}

26进制下的大数加法
AAAADH BCE   DRW UHD   D AAAAA
BFL                XYZ        D
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
#define mst(a) memset(a,0,sizeof(a))
using namespace std;
const int maxn=200+10;
char s1[maxn],s2[maxn];
int a[maxn],b[maxn];
char s[maxn];
int main()
{
    while(~scanf("%s %s",s1,s2))
    {
        mst(a);
        mst(b);
        int len1=strlen(s1);
        int len2=strlen(s2);
        for(int i=0;i<len1;i++)
        {
            int x=s1[i]-'A';
            a[len1-i-1]=x;
        }
        for(int i=0;i<len2;i++)
        {
            int x=s2[i]-'A';
            b[len2-i-1]=x;
        }
        int len=max(len1,len2);
        int pre=0;
        int k=0;
        string res="";
        for(int i=0;i<=len;i++)
        {
            int v=a[i]+b[i]+pre;
            pre=0;
            if(v>=26)
            {
                v-=26;
                pre=1;
            }
            if(v!=0)
            {
                k=i;
            }
            s[i]=v;
        }
        for(int i=0;i<=k;i++)
        {
            res+=s[i]+'A';
        }
        reverse(res.begin(),res.end());
        int n=res.length();
        int flag=0;
        for(int i=0;i<n;i++)
        {
            if(res[i]=='A')
            {
                flag=0;
            }
            else
            {
                flag=1;
                break;
            }
        }
        if(flag)
        cout<<res<<endl;
        else
        cout<<'A'<<endl;
    }
}

```





# 二分查找

```c++
int dichotomy(int arr[], int L, int R,int key)
{
	if (L <= R)
	{
		int mid = L + ((R - L) >> 1);
		if (arr[mid] == key) return mid;
		if (arr[mid] > key) dichotomy(arr, L, mid - 1, key);
		else dichotomy(arr, mid + 1, R, key);
	}
	else return R;
}
```

# 排序算法

```C++
int a[LEN], temp[LEN];

//合并有序数列，并在合并时计算逆序对
int mergeCountInversions(int a[], int left, int mid, int right)
{
	int count = 0;
	//归并到临时数组中
	int i = left, j = mid + 1;
	for (int k = left; k <= right; k++) {
		if ((j > right) || (i <= mid) && (a[i] <= a[j]))
			temp[k] = a[i++];
		else {
			temp[k] = a[j++];
			count += mid - i + 1;		//计算逆序对数
		}
	}

	//拷贝回数组a
	for (int i = left; i <= right; i++)
		a[i] = temp[i];

	return count;
}

//通过归并排序计算逆序对
int countInversions_mergeSort(int a[], int left, int right)
{
	if (left < right) {
		int mid = left + (right - left) / 2;
		//当前数组内的逆序对数等于两个子数组的逆序对数加上归并时计算出的逆序对数
		return countInversions_mergeSort(a, left, mid) 
			+ countInversions_mergeSort(a, mid + 1, right)
			+ mergeCountInversions(a, left, mid, right);
	}
	else
		return 0;
}

```



## 归并排序

```c++
//long long int ans;求逆序对
void mergesort(int arr[], int L, int R)
{
	if (L == R) return;
	int mid = L + ((R - L) >> 1);
	mergesort(arr, L, mid);
	mergesort(arr, mid + 1, R);
	merge(arr, L, R, mid);
}
void merge(int arr[], int L, int R, int mid)
{
	int* temp = new int[R - L + 1];
	int p1 = L;
	int p2 = mid + 1;
	int i = 0;
	while (p1 <= mid && p2 <= R)
	{
        //(求逆序对)if(array[p1]>array[p2]) ans+=mid-p1+1;
		temp[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
	}
	while (p1 <= mid)
	{
		temp[i++] = arr[p1++];
	}
	while (p2 <= R)
	{
		temp[i++] = arr[p2++];
	}
	for (int j = 0; j < R - L + 1; j++)
	{
		arr[L + j] = temp[j];
	}
	delete[3] temp;
}
```

## 快速排序

### 经典快排

```c++
void quicksort(int arr[], int p, int r)
{
	if (p < r)
	{
		int key = partition(arr, p, r);
		quicksort(arr, p, key - 1);
		quicksort(arr, key + 1, r);
	}
}
int partition(int arr[], int p, int r)
{
	int key = arr[r];
	int i = p - 1;
	for (int j = p; j < r; j++)
	{
		if (arr[j] <= key)
		{
			swap(arr[++i], arr[j]);
		}
	}
	swap(arr[i + 1], arr[r]);
	return i + 1;
}
void swap(int &x, int &y)
{
	int temp = x;
	x = y;
	y = temp;
}
```

### 优化1：双指针

```c++
void qsort(int arr[], int L, int R)
{
	if (L < R)
	{
		int key = arr[R];
		int i = L;
		int j = R;
		while (i < j && arr[i] <= key)i++;
		swap(arr[i], arr[j]);
		while (i < j && arr[j] >= key)j--;
		swap(arr[i], arr[j]);
		qsort(arr, L, j - 1);
		qsort(arr, i + 1, R);
	}
}
```

### 优化2：双指针+减少优化次数

```c++
void qsort(int arr[], int L, int R)
{
	if (L < R)
	{
		int key = arr[R];
		int i = L;
		int j = R;
		while (i < j && arr[i] <= key)i++;
		while (i < j && arr[j] >= key)j--;
		swap(arr[i], (i == j)?arr[R]:arr[j]);
		qsort(arr, L, j - 1);
		qsort(arr, i + 1, R);
	}
}
```

### 优化3：随机快排

```c++
void swap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
void qsort(int L, int R)
{
	if (L < R)
	{
		int pivot = rand()%(R- L) + L;
        swap(arr[pivot],arr[R]); 
		int key = arr[R];
		int i = L;
		int j = R;
		while (i < j && arr[i] <= key)i++;
		while (i < j && arr[j] >= key)j--;
		swap(arr[i], (i == j) ? arr[R] : arr[j]);
		qsort(L, j - 1);
		qsort(i + 1, R);
	}
}
```



## 堆排序

```c++
void heapsort(int arr[], int len)
{
	if (arr == NULL || len < 2) return;
	for (int i = 0; i < len; i++)
		heapinsert(arr, i);
	int heapsize = len - 1; 
	swap(arr[0], arr[heapsize--]);
	while (heapsize > 0)
	{
		heapify(arr, 0, heapsize);
		swap(arr[0], arr[heapsize--]);
	}
}
void heapinsert(int arr[], int index)
{
	while (arr[index] > arr[(index - 1)/2])
	{
		swap(arr[index], arr[(index - 1)/2]);
		index = (index - 1)/2;
	}
}
void heapify(int arr[], int index, int heapsize)
{
	int left = (index << 1) + 1;
	while (left < heapsize)
	{
		int largest = left + 1 < heapsize && arr[left + 1] > arr[left] ? left + 1 : left;
		largest = arr[largest] > arr[index] ? largest : index;
		if (largest == index) 
			break;
		swap(arr[largest], arr[index]);
		index = largest;
		left = (index << 1) + 1;
	}
}
void swap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
```

# 字符串

## BF算法(朴素字符串匹配算法)

```c++
int BF(PStr pstr1, PStr pstr2)
{
	int index = 0;
	int i = 0;
	int j = 0;
	while (pstr1->arr[i] != '\0' && pstr2->arr[j] != '\0')
	{
		if (pstr1->arr[i] == pstr2->arr[j])
		{
			i++;
			j++;
		}
		else
		{
			index++;
			i = index;
			j = 0;
		}
	}
	if (pstr2->arr[j] == '\0') return index;
	else return -1;
}
```

## KMP算法

```c++
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}





#include <iostream>

using namespace std;

const int N = 1000010;
char p[N], s[N]; // 用 p 来匹配 s
// “next” 数组，若第 i 位存储值为 k
// 说明 p[0...i] 内最长相等前后缀的前缀的最后一位下标为 k
// 即 p[0...k] == p[i-k...i]
int ne[N]; 
int n, m; // n 是模板串长度 m 是模式串长度

int main()
{
    cin >> n >> p >> m >> s;

    // p[0...0] 的区间内一定没有相等前后缀
    ne[0] = -1;

    // 构造模板串的 next 数组
    for (int i = 1, j = -1; i < n; i ++)
    {
        while (j != -1 && p[i] != p[j + 1])
        {
            // 若前后缀匹配不成功
            // 反复令 j 回退，直至到 -1 或是 s[i] == s[j + 1]
            j = ne[j];
        }
        if (p[i] == p[j + 1]) 
        {
            j ++; // 匹配成功时，最长相等前后缀变长，最长相等前后缀最后一位变大
        }
        ne[i] = j; // 令 ne[i] = j，以方便计算 next[i + 1]
    }

    // kmp start !
    for (int i = 0, j = -1; i < m; i ++)
    {
       while (j != -1 && s[i] != p[j + 1])
       {
           j = ne[j];
       }
       if (s[i] == p[j + 1])
       {
           j ++; // 匹配成功时，模板串指向下一位
       }
       if (j == n - 1) // 模板串匹配完成，第一个匹配字符下标为 0，故到 n - 1
       {
           // 匹配成功时，文本串结束位置减去模式串长度即为起始位置
           cout << i - j << ' ';

           // 模板串在模式串中出现的位置可能是重叠的
           // 需要让 j 回退到一定位置，再让 i 加 1 继续进行比较
           // 回退到 ne[j] 可以保证 j 最大，即已经成功匹配的部分最长
           j = ne[j]; 
       }
    }

   return 0;
}


```

- ABCDABD: 每一个字串里面去找前缀和后缀中相同的元素的长度
  - "A"的前缀和后缀都为空集，共有元素的长度为0；
    "AB"的
    前缀为[A]，后缀为[B]，
    共有元素的长度为0；
    "ABC"的额                                                                                                                                                                                                                                                       
    前缀为[A, AB]，后缀为[BC, C]，
    共有元素的长度0；
    
    "ABCD"的
    前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，
    共有元素的长度为0；
    "ABCDA"的
    前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；
    
    "ABCDAB"的
    前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，
    共有元素为"AB"，长度为2；
    
    "ABCDABD"的
    前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，
    后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，
    共有元素的长度为0。



# 高精度

## 高精度加法

```C++
#include<iostream>
#include<vector>
#include<string>
using namespace std;
#define VI vector<int>
VI add(VI &A ,VI &B)
{
    VI C;
    int t = 0;
    for(int i = 0;i<A.size() || i<B.size(); i++ )
    {
        if(i<A.size()) t+=A[i];
        if(i<B.size()) t+=B[i];
        C.push_back(t%10);
        t/=10;
    }
    if(t) C.push_back(t);
    return C;
}
int main()
{
    VI A,B;
    string a,b;
    cin>>a>>b;
    for(int i = a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    for(int i = b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
    auto C = add(A,B);
    for(int i = C.size()-1;i>=0;i--)
        cout<<C[i];
    return 0;
}
```



## 高精度乘法

```c++
#include<iostream>
#include<string>
using namespace std;
const int N = 10000000;
int A[N],B[N],C[N];
int main()
{
    string a,b;
    cin>>a>>b;
    int lenA = a.size(),lenB = b.size();
    for(int i = 1;i<=lenA;i++)A[i] = a[lenA-i] - '0';
    for(int i = 1;i<=lenB;i++)B[i] = b[lenB-i] - '0';
    for(int i = 1;i<=lenA;i++)
        for(int j = 1;j<=lenB;j++)
        {
            C[i+j-1] += A[i]*B[j];
            C[i+j] += C[i+j-1]/10;
            C[i+j-1] %=10;
        }
    int len = lenA+lenB;
    while(C[len] == 0 && len>1)len--;
    for(int i = len;i>=1;i--)cout<<C[i];        
    return 0;
}
```

## 高精度减法

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;
#define VI vector<int>
bool cmp(VI &A,VI &B)
{
    if(A.size()>B.size()) return true;
    else if(A.size()<B.size()) return false;
    else{
        for(int i = 0;i<A.size();i++)
            if(A[i] < B[i])
                return false;
    }
    return true;
}
VI sub(VI &A ,VI &B)
{
    VI C;
    int t = 0;
    for(int i = 0;i<A.size(); i++ )
    {
        t = A[i] -t;
        if(i<B.size()) t-=B[i];
        C.push_back((t+10)%10);
        if(t<0)t=1;
        else t=0;
    }
    while(C.size() > 1 && C.back() == 0)C.pop_back();
    return C;
}
int main()
{
    VI A,B;
    string a,b;
    cin>>a>>b;
    for(int i = a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    for(int i = b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
    if(cmp(A,B))
    {
        auto C = sub(A,B);
        for(int i = C.size()-1;i>=0;i--)
            cout<<C[i];
    }
    else{
        auto C = sub(B,A);
        cout<<"-";
        for(int i = C.size()-1;i>=0;i--)
            cout<<C[i];
    }
    
    return 0;
}
```



## 高精度除法

### 高精度除以低精度

```c++
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
#define VI vector<int>
VI div(VI &A,int b,int &r)
{
    VI C;
    r = 0;
    for(int i = A.size() - 1;i>=0;i--)
    {
        r = r*10+A[i];
        C.push_back(r/b);
        r%=b;
    }
    reverse(C.begin(),C.end());
    while(C.size()>1 && C.back() == 0) C.pop_back();
    return C;
}
int main()
{
    string a;
    int b;
    cin>>a>>b;
    VI A;
    for(int i = a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
    int r;
    auto B = div(A,b,r);
    for(int i = B.size()-1;i>=0;i--)cout<<B[i];
    return 0;
}
```

# 数学知识

## 约数

### 判断约数

```C++
bool is_primer(int n)
{
    if(n<2) return false;
    for(int i = 2;i<=n/i;i++)
        if(n % i == 0)
            return false;
    return true
}
```



### 约数个数

```cpp
#include<iostream>
#include<unordered_map>
using namespace std;
#define ll long long int
const ll N = 1e9+7;
int main()
{
    ll n,m,ans = 1;
    cin>>n;
    unordered_map<int,int> hash;
    while(n--)
    {
        cin>>m;
        for(ll i = 2;i*i<=m;i++)
        {
            while(m%i == 0)
            {
                hash[i]++;
                m/=i;
            }
        }
        if(m>1) hash[m]++;//保证不遗漏很大的因数
    }
    for(auto i:hash)
    {
        ans = (ans*(i.second+1))%N;
    }
    cout<<ans;
    return 0;
}
```

### 试除法求约数

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
bool sign[1000];
int main()
{
    int n;
    cin >> n;
    vector<int> v;
    for (int i = 1; i * i <= n; i++)
    {
        if (n % i == 0)
        {
            v.push_back(i);
            if (i != n / i)
            {
                v.push_back(n / i);
            }
        }
    }
    cout << v.size() << endl;
    sort(v.begin(), v.end());
    for (int i : v)
        cout << i << " ";
    return 0;
}
```

### 约数之和

```cpp
#include<iostream>
#include<unordered_map>
using namespace std;
#define ll long long int
const ll mod = 1e9+7;
int main()
{
    unordered_map<int,int> hash;
    ll n,m,ans = 1;
    cin>>n;
    while(n--)
    {
        cin>>m;
        for(ll i = 2;i*i<=m;i++)
        {
            while(m%i==0)
            {
                hash[i]++;
                m/=i;
            }
        }
        if(m>1) hash[m]++;
    }
    for(auto h:hash)
    {
        int i = h.first,j = h.second;
        ll res = 1;
        while(j--)
        {
            res=(res*i+1)%mod;
        }
        ans =ans*res%mod;
    }
    cout<<ans;
    return 0;
}
```

## 线性筛

### 素数性质

```C++
大于等于5的质数一定和6的倍数相邻。例如5和7，11和13等。
```



### 欧拉筛

```c++
 for(int i = 2;i<=n;i++)
{
	if(isprimer[i] == false) arry[++num] = i;
    for(int j = 1;j<=num && i*arry[j]<=n;j++)
    {
         isprimer[i*arry[j]] = true;
         if(i % arry[j] == 0) break;
    }
}
```

### 埃氏筛

```
void get_primer(int n)
{
	if(!st[i])
	{
		primer[cnt++] = i;
		for(int j = i+i;j<=n;j+=i) st[j]=true;
	}
}
```

## 同余定理

```C++
两个数的和、差、积的余数等于余数的和、差、积。
由于多个数的和、差、积可以分解为多步两个数的和、差、
积运算，所以上述结论对于多个数也成立。
```

## GCD与LCM

**GCD**

- 性质
  - gcd(a,b)=gcd(a,a+b)=gcd(a,ka+b)
  - gcd(ka,kb)=k*gcd(a,ka+b)
  - 定义多个整数的最大公约数：gcd(a,b,c)=gcd([gcd(a,b)],c)
  - 若gcd(a,b)=d,则gcd(a/b,b/d)=1,既a/d与b/d
  - gcd(a+cb,b)=gcd(a,b)

```C++
int gcd(int a,int b)
{
	return b?gcd(b,a%b):a;
}
```

**LCM**

```C++
int lcm(int a,int b)
{
	return a/gcd(a,b)*b;
}
```



# 数据结构

## 链表

### 单链表

```cpp
#include<iostream>
using namespace std;
const int N = 1000010;
int head,e[N],ne[N],index;
char a;
int k,x,n;
void init()
{
    head = -1;
    ne[head] = -1;
}
void inserthead()
{
    e[index] = x;
    ne[index] = head;
    head = index++;
}
void insertmid()
{
    e[index] = x;
    ne[index] = ne[k - 1];
    ne[k - 1] = index++;
}
void del()
{
    if(k == 0)
    {
        head = ne[head];
    }
    else
    {
        ne[k - 1] = ne[ne[k-1]];
    }
}
int main()
{
    init();
    cin>>n;
    while(n--)
    {
        cin>>a;
        if(a == 'H')//表头
        {
            cin>>x;
            inserthead();
        }
        if(a == 'D')
        {
            cin>>k;
            del();
        }
        if(a == 'I')
        {
            cin>>k>>x;
            insertmid();
        }
    }
    for(int i = head;i!=-1;i = ne[i])
	{
		cout<<e[i]<<" ";
	}
    return 0;
}
```

##   哈希

### 拉链法

```c++
const int N = 1e5+3;
int h[N],e[N],ne[N],idx;
void insert(int x)
{
    int k = (x % N +N)%N;
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx++;
}
bool query(int x)
{
    int k = (x%N+N)%N;
    for(int i = h[k];i!=-1;i=ne[i])
    {
        if(e[i] == x)
            return true;
    }
    return false;
}
```

### 开放寻址法

```C++
const int N = 1e5+3;
int h[N],null=0x3f3f3f3f;
int insert(int x)
{
    int k = (x % N +N)%N;
    while(h[k]!=null && h[k] !=x)
    {
        k++;
        if(k == N)k=0;
    }
    return k;
}
int main()
{
    memset(h,0x3f,sizeof h);
    return 0;
}
```

### 字符哈希

```C++
其实，自然溢出方法，说到底就是单Hash方法，只是把MOD变成了自动溢出，也就是MOD = 2^{64} - 1
从速度上来看，应该是 ： 自然溢出 > 单Hash > 双Hash。（也就是自然溢出 时间更小）。
从安全性上来看，应该：双Hash方法 > 单Hash方法。因为双Hash方法相当于是用两次 单 Hash的结果来比较，这样子冲突的概率会变得更低。
 

获取子串的Hash O(1)
上面我们得到的 Hash值都是前 i 个字符的字串，那么如果我们想获取 [l,r] 范围中的字串的Hash值，应该如何做。（利用Hash值，我们可以O(1) 时间来获取某个字串。）

我们先以一个具体的例子来理解。

1）例子
假设有一个 S = s_1s_2s_3s_4s_5 的字符串，根据定义，获取其 Hash值如下（我们先忽略MOD，方便理解）：

hash[0] = 0

hash[1] = s_1

hash[2] = s_1 * Base + s2

hash[3] = s_1 * Base^2 + s2 * Base + s_3

hash[4] = s_1 * Base^3 + s2 * Base^2 + s_3 * Base + s_4

hash[5] = s_1 * Base^4 + s2 * Base^3 + s_3 * Base^2 + s_4 * Base + s_5

现在我们想求字串 s_3s_4 的hash值，不难得出为s_3 * Base + s4，并且从上面观察，如果看hash[4] - hash[2]并将结果种带有s1,s2系数的项全部消掉，就是所求。但是由于Base的阶数，不能直接消掉，所以问题就转化成，将hash[2]乘一个关于Base的系数，在做差的时候将多余项消除，从而得到结果。

不难发现，对应项系数只差一个Base^2，而4 - 2 = 2(待求hash子串下标相减即可)，这样就不难推导出来此例题的求解式子。

hash[4] - hash[2] * Base^2
至此，通过对上例的归纳，可以得出如下的公式。
 

2）公式
若已知一个S = s_1s_2...s_n的字符串的hash值，hash[i], 0 \leq i \leq n，其子串s_l...s_r,对应的hash值为：

res = hash[r] - hash[l-1] * Base^{r - l + 1}

同时，Hash值是要进行取  MOD 的：

res = (hash[r] - hash[l-1] * Base^{r - l + 1}) \% MOD

看起来这个式子人畜无害，但是对于取模运算要谨慎再谨慎，注意到括号里面是减法，即有可能是负数，故做如下的修正：

res = ((hash[r] - hash[l-1] * Base^{r - l + 1}) \% MOD + MOD) \% MOD

至此得到求子串hash值公式。
```



# 前缀和差分

- 一维前缀和

```C++
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

- 二维前缀和

```C++
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

- 一维差分

```C++
d[k]=a[k]-a[k-1]
//对差分数组进行加减
给区间[l, r]中的每个数加上c：d[l] += c, d[r + 1] -= c
//得到原数组
d[i]+=d[i-1]
```

- 二维差分

```
D[i][j]=a[i][j]–a[i−1][j]–a[i][j−1]+a[i−1][j−1]
//对差分数组进行加减
D[x1][y1]     += d;     //二维区间的起点
D[x1][y2+1]   -= d;     //把x看成常数，y从y1到y2+1
D[x2+1][y1]   -= d;     //把y看成常数，x从x1到x2+1
D[x2+1][y2+1] += d;     //由于前两式把d减了2次，多减了1次，这里加1次回来
//得到原数组
d[i][j] = d[i][j]+d[i-1][j]+d[i][j-1]-d[i-1][j-1]
```

# 图论

## 最短路

### 单源最短路

#### 输出路径

```C++
#include<bits/stdc++.h>
using namespace std;
const int inf = 1e8+10;
int n,m,k;
int ma[1001][1001],dis[1001],vis[1001],pre[1001];
//ma地图，dis起点到某个点的距离，vis标记，pre记录每个下标节点的前驱节点 
void print(int x)
{
    if(pre[x]==0)return;
    print(pre[x]);
    cout<<"->"<<x;
}
void dijstra(int st)
{
    int pos=1,minn,sum=0;
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++){
        dis[i] = ma[st][i]; //标记起点st到每个点i的距离dis[i] 
        pre[i] = st;
    }
    vis[st] = 1; //标记起点st已走过 
    dis[st] = 0; //将起点st距离设为0
    pre[st] = 0; // 将起点设为0，作为递归边界 
    for(int i=1;i<=n;i++)
    {
        minn = inf;
        for(int j=1;j<=n;j++) //找到当前起点到下一个点的最短距离minn及点位pos 
        {
            if(vis[j]==0&&minn>dis[j]) //如果j点没走过且当前最小值大于dis[j]
            {
                minn = dis[j]; //更新minn
                pos = j; //记录当前最小值下标j 
            } 
        } 
        if(minn==inf)break; //没有下一个点
        vis[pos] = 1; //将当前最短路径点pos标记
        //ans[++k] = pos;
        for(int j=1;j<=n;j++)
        {
            if(vis[j]==0&&dis[j]>dis[pos]+ma[pos][j])
                {
                    dis[j] = dis[pos]+ma[pos][j];
                    pre[j] = pos; //记录j节点的前驱节点是pos 
                }
        } 
        
    } 
    
}
int main()
{
    cin>>n>>m;
    memset(pre,0,sizeof(0));
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            if(i==j) ma[i][j] = 0;
            else ma[i][j] = inf;
        }
    for(int i=1;i<=m;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        if(ma[a][b]>c) ma[a][b] = c;
    }
    dijstra(1);
    if(dis[n]!=inf){
        cout<<dis[n]<<endl<<1; //输出起点 
        print(n);//把终点传入，输出路径 
    }
    else cout<<"Sorry";
     return 0;
}
```



#### 朴素dijkstra算法

```c++
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

#### 堆优化dijkstra算法

```C++
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

#### Bellman—Ford

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 510,M=10010;
int n,m,k;
int dist[N],backup[N];
struct Edge{
    int a,b,w;
}edges[M];
int bellman_ford()
{
    memset(dist ,0x3f,sizeof dist);
    dist[1] = 0;
    for(int i = 0;i<k;i++)
    {
        memcpy(backup,dist,sizeof dist);//备份一下dist
        for(int j = 0;j<m;j++)
        {
            int a = edges[i].a,b=edges[i].b,w=edges[i].w;
            dist[b] = min(dist[b],backup[a]+w);
        }
    }
    if(dist[n] >= 0x3f3f3f/2)return -1;
    return dist[n];
}
int main()
{
    cin>>n>>m>>k;
    for(int i = 0;i<m;i++)
    {
        int a,b,w;
        cin>>a>>b>>w;
        edges[i]={a,b,w};
    }
    int t = bellman_ford();
    if(t==-1)cout<<"impossible"<<endl;
    else cout<<t<<endl;
    return 0;
}
```

#### spfa

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>

using namespace std;

typedef pair<int,int> PII;
const int N = 100010;
int n,m;
int h[N],w[N],e[N],ne[N],idx;
int dist[N];
bool st[N];
void add(int a,int b,int c)
{
    e[idx] =b,w[idx] = c,ne[idx] = h[a],h[a] = idx++;
}

int spfa()
{
    memset(dist,0x3f,sizeof dist);
    dist[1]=0;
    queue<int> q;
    q.push(1);
    st[1] = true;

    while(q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;
        for(int i = h[t];i!=-1;i=ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[t]+w[i])
            {
                dist[j] = dist[t]+w[i];
                if(!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    if(dist[n] == 0x3f3f3f3f)return -1;
    return dist[n];
}

int main()
{
    cin>>n>>m;

    memset(h,-1,sizeof h);

    while(m--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }
    int t = spfa();
    if(t==-1)cout<<"impossily"<<endl;
    else cout<<t<<endl;
    return 0;
}
```

#### spfa判断负环

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>

using namespace std;

typedef pair<int,int> PII;
const int N = 100010;
int n,m;
int h[N],w[N],e[N],ne[N],idx;
int dist[N],cnt[N];
bool st[N];
void add(int a,int b,int c)
{
    e[idx] =b,w[idx] = c,ne[idx] = h[a],h[a] = idx++;
}

bool spfa()
{
    queue<int> q;
    q.push(1);
    st[1] = true;

    while(q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;
        for(int i = h[t];i!=-1;i=ne[i])
        {
            int j = e[i];
            if(dist[j] > dist[t]+w[i])
            {
                dist[j] = dist[t]+w[i];
                cnt[j] = cnt[t]+1;
                if(cnt[j >=n])return true;
                if(!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}

int main()
{
    cin>>n>>m;

    memset(h,-1,sizeof h);

    while(m--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
    }
    if(spfa())cout<<"YES"<<endl;
    else cout<<"NO"<<endl;
    return 0;
}
```



### 多源最短路

#### floyd算法

> 给定一个  n  个点  m  条边的有向图，图中可能存在重边和自环，边权可能为负数。
>
> 再给定  k  个询问，每个询问包含两个整数  x  和  y ，表示查询从点  x  到点  y  的最短距离，如果路径不存在，则输出 impossible。
>
> 数据保证图中不存在负权回路。
>
> 输入格式
> 第一行包含三个整数  n,m,k 。
>
> 接下来  m  行，每行包含三个整数  x,y,z ，表示存在一条从点  x  到点  y  的有向边，边长为  z 。
>
> 接下来  k  行，每行包含两个整数  x,y ，表示询问点  x  到点  y  的最短距离。
>
> 输出格式
> 共  k  行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 impossible。
>
> 数据范围
> 1≤n≤200 ,
> 1≤k≤n2 
> 1≤m≤20000 ,
> 图中涉及边长绝对值均不超过  10000 。
>
> 输入样例：
> 3 3 2
> 1 2 1
> 2 3 2
> 1 3 1
> 2 1
> 1 3
> 输出样例：
> impossible
> 1

```cpp
#include<iostream>
#include<utility>
#include<cstring>
using namespace std;
const int N = 210;
const int INF = 1e9;
int dp[N][N];
int n,m,q;
void floyd()
{
    for(int k = 1;k<=n;k++)
    {
        for(int i = 1;i<=n;i++)
        {
            for(int j = 1;j<=n;j++)
                dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);
        }
    }
}
int main()
{
    cin>>n>>m>>q;
    for(int i = 1;i<=n;i++)
        for(int j = 1;j<=n;j++)
        {
            if(i == j) dp[i][j] = 0;
            else dp[i][j] = INF;
        }
    while(m--)
    {
        int x,y,z;
        cin>>x>>y>>z;
        dp[x][y] = min(dp[x][y],z);
    }
    floyd();
    while(q--)
    {
        int a,b;
        cin>>a>>b;
        if(dp[a][b]>INF / 2) puts("impossible");
        else cout<<dp[a][b]<<endl;
    }
    return 0;
}
```

#### flody求最小环

```
#include<bits/stdc++.h>
using namespace std;
int edge[105][105];
int dis[105][105];
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i!=j) edge[i][j]=dis[i][j]=1e8;//初始化
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        edge[u][v]=edge[v][u]=min(edge[u][v],d);
        dis[u][v]=dis[v][u]=edge[u][v];
    }
    int ans=1e8;
    for(int k=1;k<=n;k++)
    {
        for(int i=1;i<k;i++)
            for(int j=i+1;j<k;j++)// 注意这里i,j不能相等
                ans=min(ans,dis[i][j]+edge[j][k]+edge[k][i]);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
    }
    if(ans==1e8) printf("No solution.\n");
    else printf("%d\n",ans);
    return 0;
}


有向图
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2500+10;
int n,m;
struct node{int to;int val;};
vector<node>edge[maxn];
ll dis[maxn];
bool vis[maxn];
typedef pair<ll,int> pa;
void init()
{
    for(int i=1;i<=n;i++)
        dis[i]=1e18;
}
void dijkstra(int start)
{
    int flag=1;//用于重新设置的旗帜变量
    init();
    priority_queue<pa,vector<pa>,greater<pa> >q;
    memset(vis,0,sizeof(vis));
    dis[start]=0;
    q.push(pa(0,start));
    while(!q.empty())
    {
        int now=q.top().second;
        q.pop();
        if(vis[now]) continue;
        vis[now]=1;
        for(int i=0;i<edge[now].size();i++)
        {
            int to=edge[now][i].to;
            int val=edge[now][i].val;
            if(dis[to]>dis[now]+val)
            {
                dis[to]=dis[now]+val;
                if(!vis[to]) q.push(pa(dis[to],to));
            }
        }
        if(flag)
        {
            vis[start]=0;
            dis[start]=1e18;
            flag=0;
        }//重新设置起点
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        ll w;
        scanf("%d%d%lld",&u,&v,&w);
        node a;
        a.to=v,a.val=w;
        edge[u].push_back(a);
    }
    ll ans=1e18;
    for(int i=1;i<=n;i++)
    {
        dijkstra(i);
        ans=min(ans,dis[i]);
    }
    printf("%lld\n",ans);
    return 0;
}
```

#### 输出最小环中的所有节点

```C++
void find_path(int x, int y)
{
	if(!pass[x][y]) path[++cnt]=y;
	else{
		find_path(x, pass[x][y]);
		find_path(pass[x][y], y);
	}
}

void floyd()
{
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
			{
				if(i!=j && i!=k && j!=k && dist[i][j]+w[i][k]+w[k][j] < ans)
				{
					ans = dist[i][j] + w[i][k] + w[k][j];
					cnt=0;
					path[++cnt] = k; //先将节点k加到最小环的路径数组中
					path[++cnt] = i; //因为后面的递归不会将起点加到数组中，所以在前面先加上。
					find_path(i, j); //递归求解从i到j中的所有节点
				}
				if(dist[i][j] > dist[i][k]+dist[k][j]){
					dist[i][j] = dist[i][k]+dist[k][j];
					pass[i][j] = k; //记录中转点
				}
			}
}
```



## 拓扑排序

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 100010;
int n,m;
int h[N],e[N],ne[N],idx;
int q[N],d[N];//d存入度

void add(int a,int b)
{
    e[idx] = b,ne[idx]=h[a],h[a]=idx++;
}
bool topsort()
{
    int hh =0,tt=-1;
    for(int i = 1;i<n;i++)
    {
        if(!d[i])//将所有入度为0的点加入到队列
            q[++tt] = i;
    }
    while(hh<=tt)
    {
        int t = q[hh++];
        for(int i = h[t];i!=-1;i=ne[i])
        {
            int j = e[i];
            d[j]--;
            if(d[j] == 0) q[++tt] = j;//将后续入度为0 的点加入到队列
        }
    }
    return tt == n-1;//判断是否所有点入队
}
int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);
    for(int i = 0;i<n;i++)
    {
        int a,b;
        cin>>a>>b;
        add(a,b);
        d[b]++;
    }

    if(topsort())
    {

    }else{
        cout<<"-1"<<endl;
    }
    return 0;
}
```

## 最小生成树

### prime算法(${O(n^2)}$)

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 510,INF = 0x3f3f3f3f;
int n,m;
int g[N][N];
int dist[N];//表示这个点到集合的距离
bool st[N];

int prim()
{
    memset(dist ,0x3f,sizeof dist);

    int res = 0;//res存生成树中所有最小边之和
    for(int i = 0;i<n;i++)
    {
        int t = -1;
        for(int j=1;j<=n;j++)
        {
            if(!st[j] && (t==-1 || dist[t]>dist[j]))//!st[i] 在集合外
            {
                t=j;
            }
        }
        if(i && dist[t] == INF) return INF; 
        if(i)res +=dist[t];//只要不是第一条边,就加进去
        for(int j = 1;j<=n;j++)dist[j] = min(dist[j],g[t][j]);
        
        st[t] = true;
    }

    return res;
}


int main()
{
    cin>>n>>m;
    memset(g,0x3f,sizeof g);

    while(m--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        g[a][b] = g[b][a] = min(g[a][b],c);
    }

    int t = prim();
    if(t== INF)cout<<"impossible"<<endl;
    else cout<<t<<endl;
    return 0;
}
```

### Kruskal算法(${O(mlog^n)}$)

```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 100010;
int n,m;
int p[N];
struct Edge
{
    int a,b,w;
    bool operator< (const Edge&W)const
    {
        return w<W.w;
    }
}edges[N];
int find(int x)
{
    if(p[x] != x)p[x] = find(p[x]);
    return p[x];
}
int main()
{
    cin>>n>>m;
    for(int i = 0;i<m;i++)
    {
        int a,b,w;
        cin>>a>>b>>w;
        edges[i] = {a,b,w};
    }
    sort(edges,edges+m);
    for(int i =1;i<=n;i++)
        p[i]=i;

    int res = 0,cnt=0;
    for(int i=0;i<m;i++)
    {
        int a = edges[i].a,b=edges[i].b,w=edges[i].w;
        a=find(a),b=find(b);
        if(a!=b)
        {
            p[a]
            res+=w;
            cnt++;//当前加了多少条边
        }
    }
    if(cnt < n-1) cout<<"impossible"<<endl;
    else cout<<res<<endl;
    return 0;
}
```

### 二分图

#### 染色法(O(n+m))

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 100010,M=200010;
int n,m;
int h[N],e[M],ne[M],idx;
int color[N];
void add(int a,int b)
{
    e[idx] = b;ne[idx] = h[a],h[a]=idx++;
}
bool dfs(int u,int c)
{
    color[u] = c;
    for(int i = h[u];i!=-1;i=ne[i])
    {
        int j = e[i];
        if(!color[j])
        {
            if(!dfs(j,3-c)) return false;
            //3-c,如果是1号颜色，那么就变成2号颜色，如果是2号颜色，那么就变成1号颜色
            return true;
        }
        else if(color[j] == c)return false;
    }
}
int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);

    while (m--)
    {
        int a,b;
        cin>>a>>b;
        add(a,b),add(b,a);
    }
    
    bool flag = true;
    for(int i = 1;i<=n;i++)
        if(!color[i])
        {
            if(!dfs(i,1))
            {
                flag = false;
                break;
            }
        }

    if(flag) cout<<"Yes"<<endl;
    else cout<<"No"<<endl;
    return 0;
}
```

#### 匈牙利算法(O(mn))

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 510,M = 100010;
int n1,n2,m;
int h[N],e[M],ne[M],idx;
int match[N];
bool st[N];

void add(int a,int b)
{
    e[idx] = b,ne[idx] = h[a],h[a]=idx++;
}
bool find(int x)
{
    for(int i=h[x];i!=-1;i=ne[i])
    {
        int j = e[i];
        if(!st[j])
        {
            st[j] = true;
            if(match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}
int main()
{
    cin>>n1>>n2>>m;
    memset(h,-1,sizeof h);

    while(m--)
    {
        int a,b;
        cin>>a>>b;
        add(a,b);
    }
    int res = 0;
    for(int i = 1;i<=n1;i++)
    {
        memset(st,false,sizeof st);
        if(find(i))res++;
    }
    cout<<res<<endl;
    return 0;
}
```

 

## 最短路

### Dijkstra 单源最短路 邻接矩阵形式

```C++
/*

 \* 单源最短路径，Dijkstra算法，邻接矩阵形式，复杂度为O(n^2)

 \* 求出源beg到所有点的最短路径，传入图的顶点数和邻接矩阵cost[][]

 \* 返回各点的最短路径lowcost[]，路径pre[]，pre[i]记录beg到i路径上的父节点，pre[beg] = -1

 \* 可更改路径权类型，但是权值必须为非负，下标0~n-1

 */

const int MAXN = 1010;

const int INF = 0x3f3f3f3f; // 表示无穷

bool vis[MAXN];

int pre[MAXN];

 

void Dijkstra(int cost[][MAXN], int lowcost[], int n, int beg)

{

  for (int i = 0; i < n; i++)

  {

    lowcost[i] = INF;

    vis[i] = false;

    pre[i] = -1;

  }

  lowcost[beg] = 0;

  for (int j = 0; j < n; j++)

  {

    int k = -1;

    int min = INF;

    for (int i = 0; i < n; i++)

    {

      if (!vis[i] && lowcost[i] < min)

      {

        min = lowcost[i];

        k = i;

      }

    }

    if (k == -1)

    {

      break;

    }

    vis[k] = true;

    for (int i = 0; i < n; i++)

    {

      if (!vis[i] && lowcost[k] + cost[k][i] < lowcost[i])

      {

        lowcost[i] = lowcost[k] + cost[k][i];

        pre[i] = k;

      }

    }

  }

}
```



### Dijkstra 单源最短路 邻接矩阵形式 双路径信息

```c++
/*

 \* 单源最短路径，dijkstra算法，邻接矩阵形式，复杂度为O(n^2)

 \* 两点间距离存入map[][],两点间花费存入cost[][]

 \* 求出源st到所有点的最短路径及其对应最小花费

 \* 返回各点的最短路径lowdis[]以及对应的最小花费lowval[]

 \* 可更改路径权类型，但是权值必须为非负，下标1~n

 */

 

const int MAXN = 1010;

const int INF = 0x3f3f3f3f;

 

int n, m;

 

int lowdis[MAXN];

int lowval[MAXN];

int visit[MAXN];

int map[MAXN][MAXN];

int cost[MAXN][MAXN];

 

void dijkstra(int st)

{

  int temp = 0;

  for (int i = 1; i <= n; i++)

  {

    lowdis[i] = map[st][i];

    lowval[i] = cost[st][i];

  }

  memset(visit, 0, sizeof(visit));

 

  visit[st] = 1;

  for (int i = 1; i < n; i++)

  {

    int MIN = INF;

    for (int j = 1; j <= n; j++)

    {

      if (!visit[j] && lowdis[j] < MIN)

      {

        temp = j;

        MIN = lowdis[j];

      }

    }

    visit[temp] = 1;

    for (int j = 1; j <= n; j++)

    {

      if (!visit[j] && map[temp][j] < INF)

      {

        if (lowdis[j] > lowdis[temp] + map[temp][j])

        {

          lowdis[j] = lowdis[temp] + map[temp][j];

          lowval[j] = lowval[temp] + cost[temp][j];

        }

        else if (lowdis[j] == lowdis[temp] + map[temp][j])

        {

          if (lowval[j] > lowval[temp] + cost[temp][j])

          {

            lowval[j] = lowval[temp] + cost[temp][j];

          }

        }

      }

    }

  }

 

  return ;

}
```



### Dijkstra 起点Start 结点有权值

```C++
\#define M 505

 

const int inf = 0x3f3f3f3f;

 

int num[M];      // 结点权值

int map[M][M];    // 图的临近矩阵

int vis[M];      // 结点是否处理过

int ans[M];      // 最短路径结点权值和

int dis[M];      // 各点最短路径花费

int n, m, Start, End; // n结点数，m边数，Start起点，End终点

 

void Dij(int v)

{

  ans[v] = num[v];

  memset(vis, 0, sizeof(vis));

  for (int i = 0; i < n; ++i)

  {

    if (map[v][i] < inf)

    {

      ans[i] = ans[v] + num[i];

    }

    dis[i] = map[v][i];

  }

  dis[v] = 0;

  vis[v] = 1;

  for (int i = 1; i < n; ++i)

  {

    int u = 0, min = inf;

    for (int j = 0; j < n; ++j)

    {

      if (!vis[j] && dis[j] < min)

      {

        min = dis[j];

        u = j;

      }

    }

    vis[u] = 1;

    for (int k = 0; k < n; ++k)

    {

      if (!vis[k] && dis[k] > map[u][k] + dis[u])

      {

        dis[k] = map[u][k] + dis[u];

        ans[k] = ans[u] + num[k];

      }

    }

     for (int k = 0; k < n; ++k)

    {

      if (dis[k] == map[u][k] + dis[u])

      {

        ans[k] = max(ans[k], ans[u] + num[k]);

      }

    }

  }

  printf("%d %d\n", dis[End], ans[End]); // 输出终点最短路径花费、最短路径结点权值和

}

 

int main()

{

  scanf("%d%d%d%d", &n, &m, &Start, &End);

  for (int i = 0; i < n; ++i)

  {

    scanf("%d", &num[i]);

  }

  memset(vis, 0, sizeof(vis));

  memset(map, 0x3f, sizeof(map));

  for (int i = 0; i < m; ++i)

  {

    int x, y, z;

    scanf("%d%d%d", &x, &y, &z);

    if (map[x][y] > z)

    {

      map[x][y] = z;

      map[y][x] = z;

    }

  }

  Dij(Start);

 

  return 0;

}
```



### Dijkstra 堆优化

```C++
/* 

 \* 使用优先队列优化Dijkstra算法

 \* 复杂度O(ElongE)

 \* 注意对vector<Edge> E[MAXN]进行初始化后加边

 */

 

const int INF = 0x3f3f3f3f;

const int MAXN = 1000010;

 

struct qNode

{

  int v;

  int c;

  qNode(int _v = 0, int _c = 0) : v(_v), c(_c) {}

  bool operator < (const qNode &r) const

  {

    return c > r.c;

  }

};

 

struct Edge

{

  int v;

  int cost;

  Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) {}

};

 

vector<Edge> E[MAXN];

bool vis[MAXN];

int dist[MAXN];   // 最短路距离

 

void Dijkstra(int n, int start)   // 点的编号从1开始

{

  memset(vis, false, sizeof(vis));

  memset(dist, 0x3f, sizeof(dist));

  priority_queue<qNode> que;

 

  while (!que.empty())

  {

    que.pop();

  }

  dist[start] = 0;

  que.push(qNode(start, 0));

  qNode tmp;

 

  while (!que.empty())

  {

    tmp = que.top();

    que.pop();

    int u = tmp.v;

    if (vis[u])

    {

      continue;

    }

    vis[u] = true;

    for (int i = 0; i < E[u].size(); i++)

    {

      int v = E[u][i].v;

      int cost = E[u][i].cost;

      if (!vis[v] && dist[v] > dist[u] + cost)

      {

        dist[v] = dist[u] + cost;

        que.push(qNode(v, dist[v]));

      }

    }

  }

}

 

void addEdge(int u, int v, int w)

{

  E[u].push_back(Edge(v, w));

}
```



### 单源最短路 BellmanFord算法

```C++
/*

 \* 单源最短路BellmanFord算法，复杂度O(VE)

 \* 可以处理负边权图

 \* 可以判断是否存在负环回路，返回true，当且仅当图中不包含从源点可达的负权回路

 \* vector<Edge> E;先E.clear()初始化，然后加入所有边

 */

 

const int INF = 0x3f3f3f3f;

const int MAXN = 550;

int dist[MAXN];

struct Edge

{

  int u;

  int v;

  int cost;

  Edge(int _u = 0, int _v = 0, int _cost = 0) : u(_u), v(_v), cost(_cost){}

};

 

vector<Edge> E;

 

bool BellmanFord(int start, int n) // 编号从1开始

{

  memset(dist, 0x3f, sizeof(dist));

  dist[start] = 0;

  for (int i = 1; i < n; i++)   // 最多做n - 1次

  {

    bool flag = false;

    for (int j = 0; j < E.size(); j++)

    {

      int u = E[j].u;

      int v = E[j].v;

      int cost = E[j].cost;

      if (dist[v] > dist[u] + cost)

      {

        dist[v] = dist[u] + cost;

        flag = true;

      }

    }

    if (!flag)         // 无负环回路

    {

      return true;

    }

  }

  for (int j = 0; j < E.size(); j++)

  {

    if (dist[E[j].v] > dist[E[j].u] + E[j].cost)

    {

      return false;      // 有负环回路

    }

  }

 

  return true;          // 无负环回路

}
```

### 单源最短路 SPFA

```C++
/*

 \* 时间复杂度O(kE)

 \* 队列实现，有时候改成栈实现会更快，较容易修改

 */

 

const int MAXN = 1010;

const int INF = 0x3f3f3f3f;

 

struct Edge

{

  int v;

  int cost;

  Edge(int _v = 0, int _cost = 0) : v(_v), cost(_cost) {}

};

 

vector<Edge> E[MAXN];

 

void addEdge(int u, int v, int w)

{

  E[u].push_back(Edge(v, w));

}

 

bool vis[MAXN];   // 在队列标志

int cnt[MAXN];   // 每个点的入列队次数

int dist[MAXN];

 

bool SPFA(int start, int n)

{

  memset(vis, false, sizeof(vis));

  memset(dist, 0x3f, sizeof(dist));

 

   vis[start] = true;

  dist[start] = 0;

  queue<int> que;

 

  while (!que.empty())

  {

    que.pop();

  }

  que.push(start);

  memset(cnt, 0, sizeof(cnt));

  cnt[start] = 1;

 

  while (!que.empty())

  {

    int u = que.front();

    que.pop();

    vis[u] = false;

 

    for (int i = 0; i < E[u].size(); i++)

    {

      int v = E[u][i].v;

      if (dist[v] > dist[u] + E[u][i].cost)

      {

        dist[v] = dist[u] + E[u][i].cost;

        if (!vis[v])

        {

          vis[v] = true;

          que.push(v);

          if (++cnt[v] > n)

          {

            return false;  // cnt[i]为入队列次数，用来判定是否存在负环回路

          }

        }

      }

    }

  }

 

  return true;

}
```



### Floyd算法 邻接矩阵形式

```C++
/*

 \* Floyd算法，求从任意节点i到任意节点j的最短路径

 \* cost[][]:初始化为INF（cost[i][i]：初始化为0）

 \* lowcost[][]:最短路径，path[][]:最短路径（无限制）

 */

const int MAXN = 100;

 

int cost[MAXN][MAXN];

int lowcost[MAXN][MAXN];

int path[MAXN][MAXN];

 

void Floyd(int n)

{

  memcpy(lowcost, cost, sizeof(cost));

  memset(path, -1, sizeof(path));

 

  for (int k = 0; k < n; k++)

  {

    for (int i = 0; i < n; i++)

    {

      for (int j = 0; j < n; j++)

      {

        if (lowcost[i][j] > (lowcost[i][k] + lowcost[k][j]))

        {

          lowcost[i][j] = lowcost[i][k] + lowcost[k][j];

          path[i][j] = k;

        }

      }

    }

  }

  return ;

}
```



### Floyd算法 点权 + 路径限制

```C++
/*

 \* Floyd算法，求从任意节点i到任意节点j的最短路径

 \* cost[][]:初始化为INF（cost[i][i]：初始化为0）

 \* val[]:点权，lowcost[][]:除起点、终点外的点权之和+最短路径

 \* path[][]:路径限制，要求字典序最小的路径，下标1~N

 */

const int MAXN = 110;

const int INF = 0x1f1f1f1f;

 

int val[MAXN];     // 点权

int cost[MAXN][MAXN];

int lowcost[MAXN][MAXN];

int path[MAXN][MAXN];  // i~j路径中的第一个结点

 

void Floyd(int n)

{

  memcpy(lowcost, cost, sizeof(cost));

  for (int i = 0; i <= n; i++)

  {

    for (int j = 0; j <= n; j++)

    {

      path[i][j] = j;

    }

  }

 

  for (int k = 1; k <= n; k++)

  {

    for (int i = 1; i <= n; i++)

    {

      for (int j = 1; j <= n; j++)

      {

        int temp = lowcost[i][k] + lowcost[k][j] + val[k];

        if (lowcost[i][j] > temp)

        {

          lowcost[i][j] = temp;

          path[i][j] = path[i][k];

        }

        else if (lowcost[i][j] == temp && path[i][j] > path[i][k])

        {

          path[i][j] = path[i][k];

        }

      }

    }

  }

  return ;

}
```



## 第K短路

### Dijkstra

```C++
/*

 \* Dijkstra变形，可以证明每个点经过的次数为小于等于K，

 \* 所有Dijkstra的数组dist由一维变为二维，记录经过该点

 \* 1次、2次......k次的最小值

 \* 输出dist[n - 1][k]即可

 */

 

int g[1010][1010];

int n, m, x;

const int INF = 0x3f3f3f3f;

int vis[1010];

int dist[1010][20];

 

int main(int argc, const char * argv[])

{

  while (cin >> n >> m >> x)

  {

    //初始化

    memset(g, 0x3f, sizeof(g));

    memset(dist, 0x3f, sizeof(dist));

    memset(vis, 0, sizeof(vis));

    for (int i = 0; i < m; i++)

    {

      int p, q, r;

      cin >> p >> q >> r;

      if (r < g[p][q])

      {

        g[p][q] = r;

      }

    }

    dist[1][0] = 0;

    dist[0][0] = INF;

 

    while (1)

    {

      int k = 0;

      for (int i = 1; i <= n; i++)

      {

        if (vis[i] < x && dist[i][vis[i]] < dist[k][0])

        {

          k = i;

        }

      }

      if (k == 0)

      {

        break;

      }

      if (k == n && vis[n] == x - 1)

      {

        break;

      }

      for (int i = 1; i <= n; i++)

      {

        if (vis[i] < x && dist[k][vis[k]] + g[k][i] < dist[i][x])

        {

          dist[i][x] = dist[k][vis[k]] + g[k][i];

          for (int j = x; j > 0; j--)

          {

            if (dist[i][j] < dist[i][j - 1])

            {

               swap(dist[i][j], dist[i][j - 1]);

            }

          }

        }

      }

      vis[k]++;

    }

 

    if (dist[n][x - 1] < INF)

    {

      cout << dist[n][x - 1] << endl;

    }

    else

    {

      cout << -1 << endl;

    }

  }

  return 0;

}
```

### A*

```C++
/*

 \* A* 估价函数 fi为到当前点走过的路经长度，hi为该点到终点的长度

 \* gi = hi + fi

 */

 

int n, m, x, ct;

int g[1010][1010];

int gr[1010][1010];

int dist[1010];

int vis[1010];

const int INF = 0x3f3f3f3f;

 

struct node

{

  int id;

  int fi;

  int gi;

  friend bool operator < (node a, node b)

  {

    if (a.gi == b.gi)

    {

      return a.fi > b.fi;

    }

    return a.gi > b.gi;

  }

} s[20000010];

 

int init()

{

  memset(dist, 0x3f, sizeof(dist));

  for (int i = 0; i <= n; i++)

  {

    vis[i] = 1;

  }

  dist[n - 1] = 0;

  for (int i = 0; i < n; i++)

  {

    int k = n;

    for (int j = 0; j < n; j++)

    {

      if (vis[j] && dist[j] < dist[k])

      {

        k = j;

      }

    }

    if (k == n)

    {

      break;

    }

    vis[k] = 0;

    for (int j = 0; j < n; j++)

    {

      if (vis[j] && dist[k] + gr[k][j] < dist[j])

      {

        dist[j] = dist[k] + gr[k][j];

      }

    }

  }

  return 1;

}

 

int solve()

{

  if (dist[0] == INF)

  {

    return -1;

  }

  ct = 0;

  s[ct].id = 0;

  s[ct].fi = 0;

  s[ct++].gi = dist[0];

  int cnt = 0;

  while (ct)

  {

    int id = s[0].id;

    int fi = s[0].fi;

 

    if (id == n - 1)

    {

      cnt++;

    }

    if (cnt == x)

    {

      return fi;

    }

    pop_heap(s, s + ct);

    ct--;

    for (int j = 0; j < n; j++)

    {

      if (g[id][j] < INF)

      {

        s[ct].id = j;

        s[ct].fi = fi + g[id][j];

        s[ct].gi = s[ct].fi + dist[j];

        ct++;

        push_heap(s, s + ct);

      }

    }

  }

  return -1;

}

 

int main()

{

  while (cin >> n >> m >> x)

  {

    memset(g, 0x3f, sizeof(g));

    memset(gr, 0x3f, sizeof(gr));

 

    for (int i = 0; i < n; i++)

    {

      int p, q, r;

      cin >> p >> q >> r;

      p--;

      q--;

      g[p][q] = g[p][q] <= r ? g[p][q] : r;

      gr[q][p] = gr[q][p] <= r ? gr[q][p] : r;

    }

    init();

    cout << solve() << endl;

   }

 

  return 0;

}
```



## 最小生成树（森林）

### Prim算法

```C++
/*

 \* Prim求MST

 \* 耗费矩阵cost[][]，初始化为INF，标号从0开始，0 ~ n－1

 \* 返回最小生成树的权值，返回-1表示原图不连通

 */

 

const int INF = 0x3f3f3f3f;

const int MAXN = 110;

bool vis[MAXN];

int lowc[MAXN];

int cost[MAXN][MAXN];

 

// 修正cost（添加边）

void updata(int x, int y, int v)

{

  cost[x - 1][y - 1] = v;

  cost[y - 1][x - 1] = v;

  return ;

}

 

int Prim(int cost[][MAXN], int n)  // 0 ~ n - 1

{

  int ans = 0;

  memset(vis, false, sizeof(vis));

  vis[0] = true;

  for (int i = 1; i < n; i++)

  {

    lowc[i] = cost[0][i];

  }

  for (int i = 1; i < n; i++)

  {

    int minc = INF;

    int p = -1;

    for (int j = 0; j < n; j++)

    {

      if (!vis[j] && minc > lowc[j])

      {

        minc = lowc[j];

        p = j;

      }

    }

    if (minc == INF)

    {

      return -1; // 原图不连通

    }

    ans += minc;

    vis[p] = true;

    for (int j = 0; j < n; j++)

    {

      if (!vis[j] && lowc[j] > cost[p][j])

      {

        lowc[j] = cost[p][j];

      }

    }

  }

  return ans;

}
```



### Kruskal算法

```C++
/*

 \* Kruskal算法求MST

 \* 对边操作，并排序

 \* 切记：初始化赋值问题（tol）

 */

 

const int MAXN = 110;  // 最大点数

const int MAXM = 10000; // 最大边数

 

int F[MAXN];  // 并查集使用

 

struct Edge

{

  int u;   // 起点

  int v;   // 终点

  int w;   // 权值

} edge[MAXM];  // 存储边的信息

 

int tol;    // 边数，加边前赋值为0

 

void addEdge(int u, int v, int w)

{

  edge[tol].u = u;

  edge[tol].v = v;

  edge[tol++].w = w;

  return ;

}

 

bool cmp(Edge a, Edge b)

{

  // 排序函数，将边按照权值从小到大排序

  return a.w < b.w;

}

 

int find(int x)

{

  if (F[x] == x)

  {

    return x;

  }

  else

  {

    return F[x] = find(F[x]);

  }

}

 

int Kruskal(int n) // 传入点数，返回最小生成树的权值，如果不连通则返回-1

{

  for (int i = 0; i <= n; i++)

  {

    F[i] = i;

  }

  sort(edge, edge + tol, cmp);

 

  int cnt = 0;  // 计算加入的边数

  int ans = 0;

  for (int i = 0; i < tol; i++)

  {

    int u = edge[i].u;

    int v = edge[i].v;

    int w = edge[i].w;

    int tOne = find(u);

    int tTwo = find(v);

    if (tOne != tTwo)

    {

      ans += w;

      F[tOne] = tTwo;

      cnt++;

    }

    if (cnt == n - 1)

    {

      break;

    }

  }

  if (cnt < n - 1)

  {

    return -1; // 不连通

  }

  else

  {

    return ans;

  }

}

 

 
```

### 次小生成树

```C++
O(V^2)

次小生成树可由最小生成树转换一条边得到

只要充分利用上述结论，既得v^2的算法。具体如下： 

step1. 先用Prim求出最小生成树T，在Prim的同时，用一个矩阵MAX[u][v]记录在T中连结任意两点u，v的唯一的路中权值最大的那条边的权值。（注意这里），这是很容易做到的，因为Prim是每次增加一个结点s，而已经标好了的结点集合为w，则w中所有的结点到s的路中最大权值的边就是当前加入的这条边，用时O(V^2)； 

step2.枚举所有不在T中的边u_v，加入边u_v替换权为MAX[u][v]的边，不断更新最小值，即次小生成树，用时O(E)，故总用时O(V^2)

 

/*

 \* 求最小生成树时，用数组MAX[i][j]表示i到j的最大边权

 \* 求完后，直接枚举所有不在MST中的边，替换掉最大边权的边，更新答案

 \* 点的编号从0开始

 */

 

const int MAXN = 110;

const int INF = 0x3f3f3f3f;

 

bool vis[MAXN];

int lowc[MAXN];

int pre[MAXN];

int MAX[MAXN][MAXN];

bool used[MAXN][MAXN];

 

int Prim(int cost[][MAXN], int n)

{

  int ans = 0;

  memset(vis, false, sizeof(vis));

  memset(MAX, 0, sizeof(MAX));

  memset(used, false, sizeof(used));

  vis[0] = true;

  pre[0] = -1;

  lowc[0] = 0;

 

  for (int i = 1; i < n; i++)

  {

    lowc[i] = cost[0][i];

    pre[i] = 0;

  }

  for (int i = 1; i < n; i++)

  {

    int minc = INF;

    int p = -1;

    for (int j = 0; j < n; j++)

    {

      if (!vis[j] && minc > lowc[j])

      {

        minc = lowc[j];

        p = j;

      }

    }

    if (minc == INF)

    {

      return -1;

    }

    ans += minc;

    vis[p] = true;

    used[p][pre[p]] = used[pre[p]][p] = true;

    for (int j = 0; j < n; j++)

    {

      if (vis[j])

      {

        MAX[j][p] = MAX[p][j] = max(MAX[j][pre[p]], lowc[p]);

      }

      if (!vis[j] && lowc[j] > cost[p][j])

      {

        lowc[j] = cost[p][j];

        pre[j] = p;

      }

    }

  }

 

  return ans;

}
```

