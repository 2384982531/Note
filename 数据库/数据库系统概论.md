# 第一章 绪论

## 1.1 数据库系统概述

### 1.1.1 数据库的4个基本概念

- 数据（data）

  - **数据**是数据库中存储的基本对象
  - 描述事物的符号记录称为**数据**
  - **数据**的含义称为数据的**语义**，数据与其语义是不可分的

- 数据库（DataBase，DB）

  - 存放数据的仓库
  - 严格的讲，**数据库是长期储存在计算机内，有组织的，可共享的大量数据的集合。数据库中的数据按一定的数据模型组织，描述和储存，具有较小的冗余度（redundancy）,较高的数据独立性（data independency）和易扩展性（scalability），并可为各种用户共享**
    - 永久存储
    - 有组织
    - 可共享

- 数据库管理系统（DataBase Management System，DBMS）

  - 是位于用户于操作系统之间的一层数据管理软件
  - 主要功能
    - 数据定义功能
    - 数据组织，存储和管理
    - 数据操纵功能
    - 数据库的事物管理和运行管理
    - 数据库的建立和维护功能

- 数据库系统（DataBase System，DBS）

  - 数据库系统是由数据库，数据库管理系统（及其应用开发工具），应用程序和数据库管理员（DataBase Administrator，DBA）组成的存储，管理，处理和维护数据的系统

    ![Snipaste_2023-07-11_14-53-44](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-11_14-53-44.png)

### 1.1.2 数据管理技术的产生和发展

<table align="center" border="1">
    <tr>
        <th colspan="2"></th>
        <th>人工管理阶段</th>
        <th>文件系统阶段</th>
        <th>数据库系统阶段</th>
    </tr>
    <tr>
        <td rowspan="4">背景</td>
        <td>应用背景</td>
        <td>科学计算</td>
        <td>科学计算，数据管理</td>
        <td>大规模数据管理</td>
    </tr>
    <tr>
        <td>硬件背景</td>
        <td>无直接存取存储设备</td>
        <td>磁盘，磁鼓</td>
        <td>大容量磁盘，磁盘阵列</td>
    </tr>
    <tr>
        <td>软件背景</td>
        <td>没有操作系统</td>
        <td>有文件系统</td>
        <td>有数据库管理系统</td>
    </tr>
    <tr>
        <td>批处理</td>
        <td>联机实时处理，批处理</td>
        <td>联机实时处理，批处理</td>
        <td>联机实时处理，分布处理，批处理</td>
    </tr>
    <tr>
        <td rowspan="6">特点</td>
        <td>数据的管理者</td>
        <td>用户（程序员）</td>
        <td>文件系统</td>
        <td>数据库管理系统</td>
    </tr>
    <tr>
        <td>数据面向的对象</td>
        <td>某一应用程序</td>
        <td>某一应用</td>
        <td>现实世界（一个部门 ，企业，跨国组织等）</td>
    </tr>
    <tr>
        <td>数据的共享程度</td>
        <td>无共享，冗余度极大</td>
        <td>共享性差，冗余度大</td>
        <td>共享性高，冗余度小</td>
    </tr>
    <tr>
        <td>数据的独立性</td>
        <td>不独立，完全依赖于程序</td>
        <td>独立性差</td>
        <td>具有高度的物理学独立和一定的逻辑性独立性</td>
    </tr>
    <tr>
        <td>数据的结构化</td>
        <td>无结构</td>
        <td>记录内有结构，整体无结构</td>
        <td>整体结构化，用数据 模型描述</td>
    </tr>
    <tr>
        <td>数据控制能力</td>
        <td>应用程序自己控制</td>
        <td>应用程序自己控制</td>
        <td>由数据库管理系统提供数据安全性，完整性，并发控制和恢复能力</td>
    </tr>
</table>

- 人工管理阶段
  - 数据不保存
  - 应用程序管理数据
  - 数据不共享
  - 数据不具有独立性
  - 缺点
    - 数据的逻辑结构 或物理结构发生变化后，必须对应用程序做相应的修改，加重了程序员的负担
- 文件系统阶段
  - 数据可以长期保存
  - 由文件系统管理数据
  - 缺点
    - 数据共享性差，冗余度大
    - 数据独立性差
- 数据库管理阶段
  - 数据结构化
  - 数据的共享性高，冗余度低，易扩充
  - 数据独立性高
    - 物理独立性
      - 用戶的应用程序与数据库中数据的物理存储是相互独立的
    - 逻辑独立性
      - 用户的应用程序与数据库的逻辑结构是相互独立的
  - 数据由DBMS统一管理和控制

## 1.2 数据模型

- 是对现实世界数据特征的抽象
- 是对现实世界的模拟
- 是数据库系统的核心和基础

### 1.2.1 两类数据模型

数据模型应满足三方面要求：

- 能比较真实地模拟现实时间
- 容易为人所理解
- 便于在计算机上实现

两大类：

- 概念模型
  - 也称为信息模型
  - 是按用户的观点来对数据和信息建模，主要用于数据库设计
- 逻辑模型和物理模型
  - 逻辑模型
    - 主要包括
      - 层次模型（hierarchical moder）
      - 网状模型（network model）
      - 关系模型（relational model）
      - 面向对象数据模型（object oriented data model）
      - 对象关系数据模型（object relational data model）
      - 半结构化数据模型（semistructured data model）
    - 是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现
  - 物理模型
    - 是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方法和存取方，是面向计算机系统的

### 1.2.2 概念模型

概念模型是现实 世界到机器世界的一个中间层次，表现为：

- 用于信息世界的建模

- 是现实世界到信息世界的第一层抽象
- 数据库设计人员进行数据库设计的有力工具
- 数据库设计人员和 用户之间进行交流的语言

概念模型要求：

- 具有较强的语义表达能力
- 能够方便，直接地表达应用中的各种语义知识
- 简单，清晰，易与用户理解

信息世界中的基本概念

- 实体（entity）
  - 客观存在并相互区别的事物称为实体
- 属性（attribute）
  - 实体所具有的某一特性称为属性
- 码（key）
  - 唯一标识实体的属性集称为码
- 实体性（emtity type）
  - 具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和刻画同类实体
- 实体集（emtity set）
  - 同一类型实体的集合称为实体集
- 联系（relational）
  - 实体内部的联系
    - 指组成实体的各属性之间的联系
  - 实体之间的联系
    - 通常是指不同实体集之间的联系
    - 类型
      - 一对一 
        - 如果对于实体集A中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系。
      - 一对多
        - 如果对于实体集A中的每一个实体，实体集B中有n个实体(n≥0)与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B有一对多联系。
      - 多对多
        - 如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0)与之联系，反之，对于实体集B中的每一个实体，实体集A中也有m个实体(m≥0)与之联系，则称实体集A与实体集B具有多对多联系。例如一门课程可以同时有若干名学生选修，而一个学生可以同时选修多门课程，则课程实体与学生实体具有多对多联系。

概念模型的一种 表示方法：实体-联系 图（E-R图）

- E-R图提供了表示实体型，属性和联系的方法
- 实体性
  - 用矩形表示，框内写明实体名
- 属性
  - 用椭圆形 表示，并用无向边将其与相应的实体型连接起来 
- 联系
  - 用菱形表示，菱形框内写明联系名，并用无向边分别于 有关实体型链接起来，同时在无向边旁标上联系的类型

### 1.2.3 数据模型的组成要素

- 是严格定义的一组概念的集合

数据模型通常由**数据结构**，**数据操作**和**数据的完整性约束条件**三部分组成

- 数据结构
  - 描述数据库的组成对象以及对象之间的联系
  - 描述的内容有两类
    - 与对象的类型，内容 ，性质有关的
    - 与数据之间联系有关的对象
  - 是对系统静态特性的描述
- 数据操作
  - 是指对 数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则
  - 是对系统动态特性的描述
- 数据的完整性约束条件
  - 是一组完整性规则

### 1.2.4 常用的数据模型

数据库领域中主要的逻辑数据模型：

- 格式化模型

  - 层次模型（hierarchical model）

  - 网状模型（network model）

- 关系模型（relational model）
- 面向对象数据模型（object oriented data model）
- 对象关系数据模型（object relational data model）
- 半结构化数据模型（semistructure data model）

### 1.2.5 层次模型

​	层次模型用树形结构来表示各类实体以及实体间的联系。

1. 层次模型的数据结构

   在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型

   - 有且只有一个结点没有双亲结点，这个结点称为根节点
   - 根以外的其它结点有且只有一个双亲结点

   每个结点表示一个记录类型，记录类型之间的联系用结点之间的连线  （有相边）表示，这种联系是父子之间的一对多的联系

2. 层次模型的数据操纵与完整性约束

   层次模型的数据操纵主要有查询，插入，删除和更新。进行插入，删除，更新操作时要满足层次模型的完整性约束条件

3. 优点

   - 层次模型的数据结构比较简单清晰
   - 层次数据库的查询效率高
   - 层次数据模型提供了良好的完整性支持

4. 缺点

   - 现实世界中很多联系是非层次性的，如结点之间具有多对多联系，不适合用层次模型表示
   - 如果一个结点具有多个双亲结点等，用层次模型表示这类联系就很笨拙，只能通过引入冗余数据（易产生不一致性）或创建非自然的数据结构（引入虚拟结点）来解决。对插入和删除操作的限制比较多，因此应用程序的编写比较复杂。
   - 查询子女结点必须通过双亲结点。
   - 由于结构严密，层次命令趋于程序化。

### 1.2.6 网状模型

网状数据模型的典型代表是DBTG系统 ，亦称为CODASYL系统

1. 网状模型的数据结构

   在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型

   1. 允许一个 以上的结点无双亲
   2. 一个结点可以有多余一个的双亲

2. 网状模型的数据操纵与完整性约束

   - 支持记录码的概念
   - 保证一个联系中的双亲记录和子女记录之间是一对多的联系
   - 可以支持双亲记录和子女记录之间的某些约束条件

3. 优点

   - 能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系
   - 具有良好的性能，存取效率较高

4. 缺点

   - 结构比较复杂，而且随着应用环境的扩大，数据库的结构就变的越来越复杂，不利于最终用户掌握 
   - 网状模型的DDL、DML复杂，并且要嵌入某一种高级语言（如COBOL、C）中。用户不容易掌握，不容易使用。
   - 由于记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，因此用户必须了解系统结构的细节，加重了编写应用程序的负担。

### 1.2.7 关系模型

![Snipaste_2023-07-12_11-03-48](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-12_11-03-48.png)

术语

- 关系（relation）
  - 一个关系对应通常说的一张表
- 元组（tuple）
  - 表中 的一行即为一个元组
- 属性（attribute）
  - 表中的一列即为一个属性
- 码（key）
  - 表中的某个属性组，它可以唯一确定一个元组
- 域（domain）
  - 域是一组具有相同数据类型的值的集合
  - 属性的取值 范围来自谋和域 
- 分量
  - 元组中的  一个 属性值
- 关系模式
  - 对关系的描述，一般表示为：
    - 关系名（属性1，属性2，….，属性n）

![Snipaste_2023-07-12_11-17-40](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-12_11-17-40.png)



------

关系数据模型的操纵与完整性约束

> 关系数据模型的 操作 主要  包括查询，插入，删除，和更新数据，这些操作必须 满足关系的完整性约束 条件 

关系的完整性约束条件包括三大类：

- 实体完整性
- 参照完整性
- 用户定义的完整性

关系模型中的数据操作是集合操作，操作对象和操作结构都是对象



关系数据模型的优点

- 关系模型与格式化模型不同 ，它是建立在严格的数学概念的基础 上的
- 关系模型的概念单一
- 关系模型的存取路径对用户透明，从而具有更高的数据独立性，更好的安全保密性，也简化了程序员的工作和数据库开发的建立的工作

## 1.3 数据库系统的结构

### 1.3.1 数据库系统模式的概念

在数据模型中有“型(type)”和“值（value）”的概念

- 型
  - 指对某一类数据的结构和属性的说明
- 值
  - 是型的一个具体赋值



模式（schema）是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值

- 模式的一个具体值称为模式的一个实例（instance）
- 同一个模式可以有很多实例
- 模式是相对稳定的，而实例是相对变动的

### 1.3.2 数据库系统的三级模式结构

结构

- 外模式（external scheme）

  - 也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示

    描述的是局部逻辑结构

- 模式（scheme）

  - 也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图
  - 描述的是全局逻辑结构 

- 内模式（internal schema）

  - 也称存储模式（storage schema）,一个 数据库只有一个内模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式

![Snipaste_2023-07-12_12-26-20](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-12_12-26-20.png)

> 注意
>
> - 外模式通常是模式的子集
> - 同一个模式也可以为某一用户的多个应用程序使用 ，但一个应用程序只能使用一个外模式
> - 外模式是保证数据库安全性的一个有力措施，每个用户只能看见和访问所对应的外模式找那个的数据，数据库中的其余数据是不可见的

### 1.3.3 数据库的二级映像功能与数据独立性

两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性

- 外模式 /模式映像
- 模式/内模式映像
  - 数据库中只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一  的，它定义了数据全局逻辑结构与存储结构之间的对应关系

## 1.4 数据库系统的组成

数据库系统一般由数据库，数据库管理系统（及其开发工具），应用程序和数据管理员构成 

1. 硬件平台及数据库

   硬件资源要求

   1. 要有足够大的内存，存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序。
   2. 有足够大的磁盘或磁盘阵列等设备存放数据库，有足够大的磁带(或光盘）作数据备份。
   3. 要求系统有较高的通道能力，以提高数据传送率。

2. 软件

   主要包括

   1. 数据库管理系统。数据库管理系统是为数据库的建立、使用和维护配置的系统软件。
   2. 支持数据库管理系统运行的操作系统。
   3. 具有与数据库接口的高级语言及其编译系统，便于开发应用程序。
   4. 以数据库管理系统为核心的应用开发工具。应用开发工具是系统为应用开发人员和最终用户提供的高效率、多功能的应用生成器、第四代语言等各种软件工具。它们为数据库系统的开发和应用提供了良好的环境。
   5. 为特定应用环境开发的数据库应用系统。

3. 人员

   1. 数据库管理员（DataBase Administrator，DBA）
      1. 决定数据库中的信息内容和结构
      2. 决定数据库的存储结构和存取策略
      3. 定义数据的安全性要求和完整性约束条件
      4. 监控数据库的使用和运行
      5. 数据库的改进和重组，重构
   2. 系统分析员
      - 负责应用系统的需求分析和规范说明，要和用户及数据库管理员相结合，确定系统的硬件和软件配置，并参与数据库系统的概要设计
   3. 数据库设计人员 
      - 负责数据库中数据的确定及数据库中各级模式的 设计
      - 必须参加用户需求调查和系统分析，然后进行数据库设计
      - 通常由数据库管理人员担任
   4. 应用程序员
      - 负责设计和编写应用系统的程序模块，并进行调式和安装
   5. 用户
      1. 指最终用户（end user）
         1. 通过应用程序的用户接口使用数据库

# 第二章 关系数据库

## 2.1 关系数据结构及形式化定义

### 2.1.1 关系

- 单一的数据结构——关系
  - 现实世界的实体以及实体间的各种联系均用关系来表示
- 逻辑结构——二维表
  - 从用户角度，关系模型中数据的逻辑结构是一张二维表
- 关系模型是建立在集合代数的基础上

基本概念

- 域（Domain）

  - 域是一组具有相同数据类型的值的集合

  - > 例如，自然数、整数、实数、长度小于25字节的字符串集合、{0，1}、{男，女}、大于等于0且小于等于100的正整数等，都可以是域。

- 笛卡尔积（cartesian product）

  - 笛卡尔积是域上的一种集合运算

  - 给定一组域${D_1,D_2,......,D_n}$,允许其中的某些域是相同的，${D_1,D_2,......,D_n}$的笛卡尔积为
    $$
    D_1\times D_2 \times ... \times D_n = \{(d_1,d_2,...,d_n) | d_i\in D_i ,i=1,2,...n\}
    $$
    其中，每一个元素${(d_1,d_2,...,d_n)}$叫做一个**n元组**(n-tuple)，或简称元组(tuple)。元素中的每一个值$d_i$叫做一个**分量**(component)

  - 一个域允许的不同取值个数称为这个域的**基数**(cardinal number)

    - 若$D_i(i=1,2,...,n)$为有限集，其基数为$m_i(i=1,2,...,n)$，则$D_1 \times D_2 \times ... \times D_n$的基数M为
      $$
      M = \prod^{n}_{i=1}m_i
      $$

  - 笛卡尔积的表示方法

    - 笛卡尔积可表示为一张二维表。表中的每一行对应一个元组，表中的每一列的值来自一个域

- 关系（Relation）

  - 关系

    - $D_1 \times D_2 \times ... \times D_n$的子集叫做在域$D_1,D_2,...,D_n$上的关系，表示为$R(D_1,D_2,...,D_n)$

      R表示关系的名字，n是关系的**目**或**度**(degree)

  - 元组

    - 关系中的每个元素是关系中的元组，通常用t表示

  - 单元关系与二元关系

    - 当n=1时，称该关系为单元关系(unary relation)，或一元关系
    - 当n=2时，称该关系为二元关系(binary relation)

  - 关系的表示

    - 关系也是一个二维表，表的每行对应一个元组，表的每列对应一个域，一个属性

  - 属性

    - 关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性名，n目关系必有n个属性

  - 码

    - 候选码(Candidate key)

      - 若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码

        简单的情况：候选码只包含一个属性

    - 全码(All-key)

      - 最极端的情况
        - 关系模式的所有属性组是这个关系模式的候选码，称为全码(All-key)

    - 主码

      - 若一个关系有多个候选码，则选定其中一个为主码(Primary key)

    - 主属性

      - 候选码的诸属性称为主属性(Prime attibute)

    - 非主属性

      - 不包含在任何候选码中的属性(Non-Prime attibute)或非码属性(Non-key attibute)

  - 三类关系

    - 基本关系(基本表或基表)
      - 实际存在的表，是实际存储数据的逻辑表示
    - 查询表
      - 查询结果对应的表
    - 视图表
      - 由基本表或其他视图表导出的表，是虚表，不对呀实际存储的数据

  - 基本关系的性质

    - 列是同质的(Homegeneous)
    - 不同的列可出自同一个域，其中的每一列称为一个属性，不同的属性要给予不同的属性名
    - 列的顺序无所谓，列的次序可以任意交换
    - 任意两个元组的候选码不能相同
    - 行的顺序无所谓，行的次序可以任意交换
    - 分量必须取原子值，这是规范条件中最基本的一条

### 2.1.2 关系模式

> 关系的描述称为关系模式(relation schema)
>
> 可以形象的表示为R(U,D,DOM,F)
>
> 其中，R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的 域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合
>
> 关系模式是型，关系是值

- 元组集合的结构
  - 属性构成，属性来自的域，属性与域之间的映像关系
- 一个 关系通常赋予它的元组语义确定
- 现实的世界中还存在着完整性约束
- 关系模式与关系
  - 关系模式是静态的，稳定的
  - 关系是动态的，随时间不断变化的
  - 关系是关系模式在某一时刻的状态或内容

### 2.1.3 关系数据库

在一个给定的应用领域中，所有关系的集合构成一个关系数据库

- 关系数据库的型与值
  - 关系数据库的型
    - 也称为关系数据库模式，是对关系数据库的描述
  - 关系数据库的值
    - 是这些关系模式在某一时刻对应的关系的集合，通常称为关系数据库
  - 关系数据库的模式
    - 若干域的定义，在这些域上定义的若干关系模式

### 2.1.4 关系模型的存储结构

- 有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成；
- 有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理。

## 2.2 关系操作

### 2.2.1 基本的关系操作

1. 常用的关系操作
   - 查询(query)
     - 选择(select)，投影(project)，连接(join)，除(divide)，并(union)，差(except)，交(intersection)，笛卡尔积
     - 其中选择，投影，并，差，笛卡尔积是5种基本操作
   - 数据更新
     - 插入，删除，修改
   - 查询的表达能力是其中最主要的部分
2. 关系操作的特点
   - 集合操作方式
     - 操作的对象和结果都是集合，一次一集合的方式

### 2.2.2 关系数据语言的分类

1. 关系代数语言
   - 用对关系的运算来表达查询要求，代表ISBL
2. 关系演算语言
   - 用谓词来表达查询要求
   - 元组关系演算语言
     - 谓词变元的基本对象是元组变量，代表APLHA，QUEL
   - 域关系演算语言 
     - 谓词变元的基本对象是域变量，代表QBE
3. 具有关系代数和关系演算双重特点的语言
   - 代表：SQL

## 2.3 关系的完整性

关系模型中有三类完整性约束

- 实体完整性(entity integrity)
- 参照完整性(referential integrity)
- 用户定义的完整性(user-defined inte)

> 其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。

### 2.3.1 实体完整性

关系数据库中每个元组应该是可区分的，是唯一的。这样的约束条件用实体完整性来保证

- 实体完整性规则

  若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值(不存在，不知道，无意义)

  1. 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。例如学生关系对应于学生的集合。
  2. 现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。
  3. 相应地，关系模型中以主码作为唯一性标识。
  4. 主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性。

### 2.3.2 参照完整性

在关系模型种实体及实体间的联系都是用关系来描述的，存在着关系与关系间的引用

> 设F是基本关系R的一个或一组属性，但不是关系R的码，K,是基本关系S的**主码**。如果F与K,相对应，则称F是R的**外码(foreign key)**，并称基本关系R为参照关系(referencing relation)，基本关系S为被参照关系(referenced relation) 或目标关系(target relation)。关系R和S不一定是不同的关系。
>
> ![Snipaste_2023-07-15_08-32-25](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-15_08-32-25.png)

- 说明
  - 关系R和S不一定是不同的关系
  - 目标关系S的主码$K_S$和参照关系的外码F必须定义在同一个(或一组)域上
  - 外码并不一定要与相应的主码同名，当外码与相应的主码同名，当外码与相应的主码属于不同关系时，往往取相同的名字，以便识别
- 参照完整性规则
  - 若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码$K_S$，相对应(基本关系R和S不一定是不同的关系)，则对于R中每个元组在F上的值必须：
    - 或者取空值(F的每个属性值均为空值)；
    - 或者等于S中某个元组的主码值。

### 2.3.3 用户定义的完整性

​	针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求

​	关系模型应提供定义和校验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能

## 2.4 关系代数

关系代数是一种抽象的查询语言，是对关系的运算来表达查询

关系代数的运算对象是关系，运算结果也是关系

关系代数按运算符的不同可分为传统的集合运算和专门的关系运算两类

集合运算是从关系的水平方向即行的角度进行

专门的关系运算不仅涉及行而且涉及列

![Snipaste_2023-07-16_08-53-14](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-16_08-53-14.png)

### 2.4.1 传统的集合运算

传统的集合运算是二目运算，包括，并，差，交 ，笛卡尔积4中运算

------

设关系R和关系S具有相同的目n(即两个关系都有n个属性)，且相应的属性取自同一个域，t是元组变量，$t \in R$表示t是R的一个元组

- 并(union)

  - 关系R与关系S的并记作
    $$
    R \cup S = \{t|t\in R\lor t\in S\}
    $$

  - 其结果仍为n目关系，由属于R或属于S的元组组成

- 差(except)

  - 关系 R与关系S的差记作
    $$
    R - S = \{t|t\in R \land t\notin S\}
    $$

  - 其结果仍为n目关系，由属于R而不属于S的所有元组组成

- 交(intersection)

  - 关系S与R的交记作
    $$
    R\cap S =\{t|t\in R \land t \in S\}
    $$

  - 其结果仍为n目关系，由既属于R又属于S的元组组成。关系的交可以用差来表示
    $$
    R \cap S = R-(R-S)
    $$

- 笛卡尔积(cartesian product)

  - 严格地讲应该是广义的笛卡尔积

    $R：n目关系，k_1个元组，S:m目关系，k_2个元组$

  - R与S的笛卡尔积 运算表示为$R\times S$
    $$
    R \times S = \{\overset{\LARGE{\frown}}{t_r t_s}\in R \land t_s \in S\}
    $$

  - 运算结果为

    - 行：$k_1 \times k_2$个 元组
    - 列：(n+m)列元组的集合，其中元组的前n列是关系R的一个元组，后m列是关系S的一个 元组

  ![Snipaste_2023-07-16_09-24-26](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-16_09-24-26.png)

### 2.4.2 专门的关系运算

专门的关系运算包括选择，投影，连接，除运算等

相关记号说明：

1. 关系模式为R$(A_1,A_2,...,A_n)$，它的一个关系设为R。$T\in R$表示t是R的一个元组$t[A_i]$则表示元组t中相应于属性$A_i$的一个分量

2. 若$A=\{A_{i1},A_{i2},...,A_{ik}\}$，其中$A_{i1},A_{i2},...,A_{ik}$是$A_1,A_2,...,A_n$中的一部分，则A称为属性列或属性组。$t[A] = (t[A_{i1}],t[A_{i2}],...,t[A_{ik}])$表示元组t在属性列A上诸分量的集合，$\overline{A}$则表示${A_{i1},A_{i2},...,A_{ik}}$中去掉$\{A_{i1},A_{i2},...,A_{ik}\}$后剩余的属性组。

3. R为n目关系，S为m目关系。$t_r\in R,t_x \in S, \overset{\LARGE{\frown}}{t_r t_x}$称为元组的连接（concatenation）或元组的串接。它是一个n+m列的元组，前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。

4. 给定一个关系R（X,Z）,X和Z为属性组。当r[X]=x时，x在R中的象集（imagesset)定义为
   $$
   Z_x=\{t[z] | t \in R,t[X]=x\}
   $$
   它表示R中属性组X上的值为x的诸元组在Z上分量的集合

   ------

- 选择(selection)

  > 选择又称为限制(restriction)。它是在关系R中选择满足给定条件的诸元组，记作
  > $$
  > \sigma_F(R) = \{t|\in R \land F(t)='真'\}
  > $$
  > 其中F表示选择条件，它是一个逻辑表达式，取逻辑值“真”或“假”。逻辑表达式F的基本形式为：
  > $$
  > X_1\theta T_1
  > $$
  > 其中θ表示比较运算符，它可以是>，≥，<，≤，=或<>。$X_1,Y_1$等是属性名，或为常量，或为简单函数；属性名也可以用它的序号来代替。在基本的选择条件上可以进一步进行逻辑运算，即进行求非（$\neg$）、与（$\land$）、或（V)运算。条件表达式中的运算符如表2.5所示。
  >
  > ![Snipaste_2023-07-16_16-00-12](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-16_16-00-12.png)

- 投影(projection)

  - 关系R上的投影是从R中选择若干属性列组成新的关系。记作：

    $\Pi_A(R)=\{t[A]|t\in R\}$

    其中A为R中的属性列

    投影操作是从列的角度进行的运算

- 连接(join)

  - 连接也称 为$\theta$连接。它是从两个关系 的笛卡尔积中选取属性间满足一定条件的元组。记作：
    $$
    R \underset{A\theta B }{\bowtie} S = \{\overset{\LARGE{\frown}}{t_r t_s}|t_r \in R \land t_x \in S\land t_r[A]\theta t_x[B]\}
    $$
    其中，A和B分别为R和S上列数相等且可比的属性组，O是比较运算符。连接运算从R和S的笛卡儿积R×S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系${\theta}$

  - 两类常用连接运算

    - 等值连接(equijoin)

      - ${\theta}$为"="的连接运算称为等值连接 

      - 等值连接的含义

        - 从关系R与S的广义笛卡尔积中选取A，B属性值相等的那些元组 

        $$
        R \underset{A=B}{\bowtie} S = \{\overset{\LARGE{\frown}}{t_r t_s}|t_r \in R \land t_x \in S\land t_r[A]= t_x[B]\}
        $$

    - 自然连接(Natural join)

      - 自然连接是一种特殊的等值连接，两个关系中进行比较的分量必须是相同属性组，在结果中把重复的属性列去掉

      - 自然连接的含义

        - R和S具有相同的属性组B

        $$
        R \bowtie S = \{\overset{\LARGE{\frown}}{t_r t_s}|t_r \in R \land t_x \in S\land t_r[A]= t_x[B]\}
        $$

      - 自然连接还需要取消重复列，所以是同从行和列的角度进行运算。

  - 概念

    - 悬浮元组
      - 两个关系R和S在自然连接时，关系R和S中被舍弃的元组称为悬浮元组。
    - 外连接
      - 如果把悬浮元组也保存在结果关系中，而在其他属性上填空值（NULL)，那么这种连接就叫做外连接(outer join)，记作R ⟗S；
    - 左外连接
      - 如果只保留左边关系R中的悬浮元组就叫做左外连接（left outer join 或left join)，记作R⟕S；
    - 右外连接
      - 如果只保留右边关系S中的悬浮元组就叫做右外连接(right outer join或right join),记作R ⟖S

- 除运算(divsion)

  - 给定关系R（X，Y)和S（Y，Z），其中X，Y，Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集

    R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影，元组在X上分量值x的象集Yx包含S在Y上投影的集合，记作：
    $$
    R\div S = {t_r[x]|t_r\in R \land \Pi_r(S) \subseteq Y_x}
    $$
    其中$Y_x$为x在R中的象集，$x=t_r[x]$

    除操作是同时从行和列角度进行运算

## 2.5 关系演算

关系演算是以数理逻辑中的谓词演算为基础的。按谓词变元的不同，关系演算可分为元组关系演算和域关系演算。

### 2.5.1 元组关系演算语言ALPHA

元组关系演算以元组变量作为谓词变元的基本对象。一种典型的元组关系演算语言是E.F.Codd提出的ALPHA语言。

ALPHA语言主要有GET、PUT、HOLD、UPDATE、DELETE、DROP 6条语句，语句的基本格式为：
$$
操作语句 工作空间名(表达式)：操作条件
$$

- 表达式
  - 用于指定语句的操作对象，它可以是关系名或(和）属性名，一条语句可以同时操作多个关系或多个属性。
- 操作条件
  - 是一个逻辑表达式，用于将操作结果限定在满足条件的元组中，操作条件可以为空。
- 还可以在基本格式的基础上加上排序要求以及播定返回元组的条数等。

------

- 检索操作

  用GET语句实现

  ![Snipaste_2023-07-16_20-54-04](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-16_20-54-04.png)

  ![Snipaste_2023-07-16_20-54-33](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-16_20-54-33.png)

  - 元组变量主要有两方面的用途：
    - 简化关系名。如果关系的名字很长，使用起来就会感到不方便，这时可以设一个较短名字的元组变量来代替关系名。
    - 操作条件中使用量词时必须用元组变量。

# 第三章 关系数据库标准语言SQL

## 3.1 SQL概述

### 3.1.1 SQL的产生与发展 

![Snipaste_2023-07-16_21-00-57](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-16_21-00-57.png)

### 3.1.2 SQL的特点

主要特点：

1. 综合统一

   - 集数据定义语言(DDL)、数据操纵语言(DML)、数据控制语言(DCL)的功能于一体}

   - 数据操作统一
   - 可以独立完成数据库生命周期中的全部活动，包括以下一系列操作要求：
     - 定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库。
     - 对数据库中的数据进行查询和更新。
     - 数据库重构和维护。数据库安全性、完整性控制，以及事务控制。
     - 嵌入式SQL和动态SQL定义。
   - 用户在数据库系统投入运行后还可根据需要随时地、逐步地修改模式，并不影响数据库的运行，从而使系统具有良好的可扩展性。

2. 高度非过程化

   - 非关系数据模型的数据操纵语言是“面向过程”的语言，用“过程化”语言完成某项请求必须指定存取路径。
   - 只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。
   - 存取路径的选择以及SQL的操作过程由系统自动完成。

3. 面向集合的操作方式

   - 非关系数据模型采用的是面向记录的操作方式，操作对象是一条记录。
   - SQL采用集合操作方式
     - 操作对象、查找结果可以是元组的集合；
     - 一次插入、删除、更新操作的对象可以是元组的集合

4. 以同一种语法结构提供多种使用方式

   - SQL是独立的语言
      - 能够独立的用于联机交互的使用方式
   - SQL又是嵌入式语言
      - SQL语句能够嵌入到高级语言（例如C、C++、Java)程序中，供程序员设计程序时使用。

5. 语言简洁，易学易用

   ![Snipaste_2023-07-17_10-12-01](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-17_10-12-01.png)

### 3.1.3 SQL的基本概念

SQL支持关系数据库三级模式结构![Snipaste_2023-07-17_10-14-12](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-17_10-14-12.png)

- 基本表
  - 本身独立存在的表；
  - SQL中一个关系就对应一个基本表；
  - 一个（或多个）基本表对应一个存储文件；
  - 一个表可以带若干索引。
- 存储文件
  - 逻辑结构组成了关系数据库的内模式；
  - 物理结构是任意的，对用户透明。
- 视图
  - 从一个或几个基本表导出的表；
  - 数据库中只存放视图的定义而不存放视图对应的数据
  - 视图是一个虚表；
  - 用户可以在视图上再定义视图。

## 3.3 数据定义

SQL的数据定义功能：模式定义，表定义，视图和索引的定义

![Snipaste_2023-07-17_10-14-12](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-17_10-14-12.png)

一个关系数据库管理系统的实例(instance)中可以建立多个数据库，一个 数据库中可以建立多个模式，一个模式下通常包括多个表，视图，和索引等数据库对象 

### 3.3.1 模式的定义和删除

1. 定义模式

   - 在SQL中，模式定义语句如下

     CREATE SCHEMA<模式名>AUTHORIZATION<用户名>;

# 第四章 数据库安全性

数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露，更改或破坏

数据库安全保护措施是否有效是数据库系统的主要技术指标之一

## 4.1 数据库安全性概述

### 4.1.1 数据库的不安全因素

1. 非授权用户对数据库的恶意存取和破坏
   - 安全措施
     - 用户身份鉴别
     - 存取控制和视图 
2. 数据库中重要或敏感的数据被泄露
   - 安全措施
     - 强制存取控制
     - 数据加密存储
     - 加密传输
3. 安全环境的脆弱性 

### 4.1.2 安全标准简介

![Snipaste_2023-07-20_19-45-47](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-20_19-45-47.png)

![Snipaste_2023-07-27_07-53-32](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_07-53-32.png)

- D级
  - 该级是最低级别。保留D级的目的是为了将一切不符合更高标准的系统统统归于D组。
- C1级
  - 该级只提供了非常初级的自主安全保护，能够实现对用户和数据的分离，进行自主存取控制(DAC)，保护或限制用户权限的传播。
- C2级
  - 该级实际上是安全产品的最低档，提供受控的存取保护，即将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离。达到C2级的产品在其名称中往往不突出“安全”isecurity）这一特色，
- B1级
  - 标记安全保护。对系统的数据加以标记，并对标记的主体和客体实施强制存取控制（MAC）以及审计等安全机制。B1级别的产品才被认为是真正意义上的安全产品，满足此级别的产品前一般多冠以“安全”(security）或“可信的”（trusted）字样，作为区别于普通产品的安全产品出售。
- B2级
  - 结构化保护。建立形式化的安全策略模型，并对系统内的所有主体和客体实施DAC和MAC。
- B3级
  - 安全域。该级的TCB(Trusted Computing Base）必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程。
- A1级
  - 验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证，以确信各安全保护真正实现。

------

- CC标准

  - 提出国际公认的表述信息技术安全性的结构，把信息产品的安全要求分为安全功能要求、安全保证

  - CC文本组成，三个部分缺一不可，相互依存

    - 第一部分是简介和一般模型，介绍CC中的有关术语、基本概念和一般模型以及与评估有关的一些框架。
    - 第二部分是安全功能要求，列出了一系列类、子类和组件。由11大类、66个子类和135个组件构成。
    - 第三部分是安全保证要求，列出了一系列保证类、子类和组件，包括7大类、26个子类和74个组件。根据系统对安全保证要求的支持情况提出了评估保证级（EvaluationAssurance Level,EAL），从EAL1至EAL7共分为7级，按保证程度逐渐增高。

    ![Snipaste_2023-07-27_08-01-34](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_08-01-34.png)

## 4.2 数据库安全性控制

1. 非法使用数据库的情况

   1. 编写合法程序绕过数据库管理系统及其授权机制
   2. 直接或编写应用程序执行非授权操作。
   3. 通过多次合法查询数据库从中推导出一些保密数据

2. 计算机系统的安全模型

   ![Snipaste_2023-07-27_08-09-04](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_08-09-04.png)

3. 数据库有关的安全性

   1. 数据库安全性主要包括
      1. 用户身份验证
      2. 多层存取控制
      3. 审计
      4. 视图
      5. 数据加密等安全技术

   ![Snipaste_2023-07-27_08-44-23](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_08-44-23.png)

### 4.2.1 用户身份鉴别

- 用户身份鉴别的方法
  1. 静态口令鉴别：
     - 静态口令一般由用户自己设定，这些口令是静态不变的。
  2. 动态 口令鉴别
     - 这种方式的口令是动态变化的，每次鉴别时均需使用动态产生的新口令登录数据库管理系统，即采用一次一密的方法。
  3. 生物特征鉴别
     - 它是一种通过生物特征进行认证的技术，其中，生物特征是指生物体唯一具有的，可测量、识别和验证的稳定生物特征，如指纹、虹膜和掌纹等。
  4. 智能卡鉴别
     - 智能卡是一种不可复制的硬件，内置集成电路的芯片，具有硬件加密功能。

### 4.2.1 存取控制

存取控制机制组成

- 定义用户权限
  - 并将用户权限登记到数据字典中
  - 权限是指用户对某一数据对象的操作权力。
  - DBMS提供适当的语言来定义用户权限，存放在数据字典中，称做安全规则或授权规则。
- 合法权限检查
  - 用户发出存取数据库操作请求。
  - DBMS查找数据字典，进行合法权限检查。



常用存取控制方法

- 自主存取控制
  - 自主存取控制(Discretionary Access Control,简称DAC）中用户对不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，用户可将其拥有的存取权限转授给其他用户。C2级的数据库管理系统支持自主存取控制。
- 强制存取控制
  - 强制存取控制（Mandatory Access Control,简称 MAC）中每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证，对于任意一个对象，只有具有合法许可证的用户才可以存取。B1级的数据库管理系统支持强制存取控制。

### 4.2.3 自主存取控制方法

![Snipaste_2023-07-27_09-15-07](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_09-15-07.png)

SQL标准的通过GRANT语句和REVOKE语句实现自主存取控制。

1. 用户权限概念
   1. 定义用户存取权限就是定义用户可以在哪些数据库对象哪些类型的操作。定义存取权限称为授权。
2. 用户权限组成
   1. 数据对象、操作类型
3. 关系数据库系统中存取控制对象

### 4.2.4 授权：授予与收回

SQL中使用GRANT和REVOKE语句向用户授予或收回对数据的操作权限。GRANT语句向用户授予权限，REVOKE语句收回已经授予用户的权限。

![Snipaste_2023-07-27_17-01-40](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_17-01-40.png)

如果加了最后一句，被授权用户才可以授权给 其他人![Snipaste_2023-07-27_17-02-50](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_17-02-50.png)

![Snipaste_2023-07-27_17-04-32](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_17-04-32.png)

- 创建数据库模式的权限

  ![Snipaste_2023-07-27_17-05-39](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_17-05-39.png)

  - 说明

    - 只有系统的超级用户才有权创建一个新的数据库用户。
    - 新创建的数据库用户有三种权限：CONNECT、RESOURCE和DBA。
    - CREATEUSER命令中如果没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库。由数据库管理员或其他用户授予他应有的权限，根据获得的授权情况他可以对数据库对象进行权限范围内的操作。
    - 拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主，但不能创建模式，不能创建新的用户。数据库对象的属主可以使用GRANT语句把该对象上的存取权限授予其他用户。
    - 拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。

    ![Snipaste_2023-07-27_17-07-11](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_17-07-11.png)

### 4.2.5 数据库角色

 数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合

![Snipaste_2023-07-27_17-16-36](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_17-16-36.png)

> - ①该语句把角色授予某用户，或授予另一个角色
> - 授予者是角色创建者或拥有在这个角色上的ADMIN OPTION
> - 指定了WITH ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色。

![Snipaste_2023-07-27_17-18-54](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-27_17-18-54.png)

### 4.2.6 强制存取控制方法

1. 自主存取控制缺点
   - 可能存在数据"无意泄露"的风险
   - 原因
     - 这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记
   - 解决
     - 对系统控制下的所有主客体实施强制存取控制策略
2. 强制存取控制(MAC)
   - 保证更高程度的安全性，用户不能直接感知或进行控制
   - 适用于对数据有严格而固定密级分类的部门，如军事部门等
   - 敏感度标记（Label）
     - 对于主体和客体，DBMS为它们每个实例（值）指派一个敏感度标记（Label）
   - 敏感度标记级别
     - 绝密（Top Secret，TS）、机密（Secret，S）、可信（Confidential,C）、公开（Public,P）等。
   - 密级的次序是TS>=S>=C>=P。
   - 主体的敏感度标记称为许可证级别
   - 客体的敏感度标记称为密级
3. 强制存取控制规则
   1. 仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体。
   2. 仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体。

4. 说明

   1. 强制存取控制（MAC）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。
   2. 实现强制存取控制时要首先实现自主存取控制
      1. 原因：较高安全性级别提供的安全保护要包含较低级别的所有保护。
   3. 自主存取控制与强制存取控制共同构成数据库管理系统的安全机制。

   ![Snipaste_2023-07-29_09-42-26](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-29_09-42-26.png)

## 4.3 视图机制

- 视图对数据库安全的作用
  - 把要保密的数据对无权存取这些数据的用户  隐藏起来，对数据提供一定程度 的安全保护 
  - 间接的实现支持存取谓词的用户权限定义

## 4.4 审计（Audit）

- 什么是审计
  - 审计日志（Audit Log）：启用一个专用的审计日志，将用户对数据库的所有操作记录在上面。
  - 审计员：审计员利用审计日志监控数据库中的各种行为找出非法存取数据的人、时间和内容。
  - C2以上安全级别的DBMS必须具有审计功能。
- 审计事件
  - 服务器事件
    - 审计数据库服务器发生的事件，包含数据库服务器的启动、停止、数据库服务器配置文件的重新加载。·
  - 系统权限
    - 对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通过系统权限获得的。
  - ·语句事件
    - 对SQL语句，如DDL、DML、DQL（Data Query Language，数据查询语言）及DCL语句的审计。
  - 模式对象事件
    - 对特定模式对象上进行的SELECT或DML操作的审计。模式对象包括表、视图、存储过程、函数等。模式对象不包括依附于表的索引、约束、触发器、分区表等。
- 审计功能
  - 基本功能，提供多种审计查阅方式：基本的、可选的、有限的，等等。
  - 提供多套审计规则，审计规则一般在数据库初始化时设定，以方便审计员管理。
  - 提供审计分析和报表功能。
  - 审计日志管理功能
    - 防止审计员误删审计记录，审计日志必须先转储后删除；
    - 对转储的审计记录文件提供完整性和保密性保护；
    - 只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录；
  - 系统提供查询审计设置及审计记录信息的专门视图。对于系统权限级别、语句级别及模式对象级别的审计记录也可通过相关的系统表直接查看。
- 审计分类
  - 用户级审计
    - 任何用户可设置的审计，主要是用户针对自己创建的数据库表和视图进行审计。
  - 系统级审计
    - 只能由数据库管理员设置，监测成功或失败的登录要求，检测授权和收回操作以及其他数据库级权限下的操作。
- 语句
  - AUDIT语句设置审计功能
  - NOAUDIT语句取消审计功能
- 说明
  - 审计设置以及审计日志一般都存储在数据字典中。
  - 必须把审计开关打开（即把系统参数audit trail 设为true),才可以在系统表SYS AUDITTRAIL中查看到审计信息。
  - 数据库安全审计系统提供了一种事后检查的安全机制。

## 4.5 数据加密

数据加密是防止数据库数据在存储和传输中失密的有效手段。

加密的基本思想是根据一定的算法将原始数据——明文(plain text)变换为不可直接识别的格式——密文(cipher text），从而使得不知道解密算法的人无法获知数据的内容。

数据加密主要包括存储加密和传输加密。

- 存储加密
  - 透明存储加密
    - 内核级加密保护方式，对用户完全透明
    - 将数据在写到磁盘时对数据进行加密，授权用户读取数据时在对其进行解密
    - 数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可
    - 内核级加密方法
      - 性能较好，安全完备性较高
  - 非透明存储加密
    - 通过多个加密函数实现
- 传输加密
  - 链路加密
    - 在链路层进行加密
    - 传输信息由报头和报文两部分组成，报文和报头均加密
  - 端到端加密
    - 在发送端加密，接收端解密
    - 只加密报文不加密报头
    - 所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息

![Snipaste_2023-07-29_10-07-28](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-29_10-07-28.png)

## 4.6 其它安全性保护  

- 推理控制
  - 处理强制存取控制未解决的问题，避免用户利用能够访问的数据推知更高密级的数据。
  - 常用方法：基于函数依赖的推理控制、基于敏感关联的推理控制。
- 隐蔽信道
  - 处理强制存取控制未解决的问题。
- 数据隐私保护
  - 描述个人控制其不愿他人知道或他人不便知道的个人数据的能力。主要用于数据收集存储处理和数据发布等各个阶段。

# 第五章 数据库完整性

- 数据库的完整性
  - 指数据的正确性和相容性
  - 正确性
    - 指数据是符合现实世界语义，反映了当前实际状况的
  - 相容性
    - 指数据库同一对象在不同关系表中的数据是符合逻辑的
  - 防止数据库中存在不符合语义的数据，也就是防止数据库存在不正确的数据
    - 防范对象
      - 不合语义的，不正确的数据
- 数据的安全性
  - 保护数据库防止恶意的破坏和非法的存取
    - 防范对象
      - 非法用户和非法操作

- 数据库在完整性方面应具备的功能
  - 提供定义完整性约束条件的机制
  - 提供完整性检查的方法
- 违约处理

## 5.1 实体完整性

### 5.1.1 定义实体完整性

- 关系模型的实体完整性
  - 设置主码，让每条记录是相互可区分的，SQL中在CREATE,TABLE中用PRIMARY KEY定义。
- 主码是单属性构成的有两种说明方法
  - 定义为列级约束条件
  - 定义为表级约束条件
- 主码是多属性的只能有一种说明方法
  - 定义为表级约束条件

### 5.1.2 实体完整性检查和违约处理

- 完整性检查的内容

  关系数据库管理系统按照实体完整性规则自动进行检查。检查内容主要包括：

  - 检查主码值是否唯一，如果不唯一则拒绝插入或修改。
  - 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。

## 5.2 参照完整性

### 5.2.1 定义参照完整性

- 参照完整性定义
  - 在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码，用REFERENCES短语指明这些外码参照哪些表的主码。

### 5.2.2 参照完整性检查和违约处理

一个参照完整性将两个表中的相应元组联系起来，对被参照表和参照表进行增删改操作时都有可能破坏参照完整性，必须进行完整性检查

![Snipaste_2023-08-02_10-51-16](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-02_10-51-16.png)

- 参照完整性违约处理规则
  - 拒绝（NOACTION）执行
    - 不允许该操作执行。该策略一般设置为默认策略。
  - 级联（CASCADE）操作
    - 当删除或修改被参照表（Student）的一个元组导致与参照表（SC)的不一致时，删除或修改参照表中的所有导致不一致的元组。
  - 设置为空
    - 值当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。

## 5.3 用户定义的完整性

​	用户定义的完整性就是针对某一具体应用的数据必须满足的语义要求。目前的关系数据库管理系统都提供了定义和检验这类完整性的机制，使用了和实体完整性、参照完整性相同的技术和方法来处理它们，而不必由应用程序承担这一功能。

### 5.3.1属性上的约束条件 

1. 属性上约束条件的定义

   在CREATE TABLE中定义属性的同时，可以根据应用要求定义属性上的约束条件，即属性值限制，包括：

   - 列值非空（NOTNULL）。
   - 列值唯一（UNIQUE）。
   - 检查列值是否满足一个条件表达式（CHECK短语）。

2. 属性上约束条件的检查和违约处理

   当往表中插入元组或修改属性的值时，关系数据库管理系统将检查属性上的约束条件是否被满足，如果不满足则操作被拒绝执行。

### 5.3.2 元组上的约束条件

1. 元组上约束条件的定义

   - 在CREATETABLE语句中可以用CHECK短语定义元组上的约束条件，即元组级的限制。
   - 同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件。

2. 元组上约束条件的检查和违约处理

   当往表中插入元组或修改属性的值时，关系数据库管理系统将检查元组上的约束条件是否被满足，如果不满足则操作被拒绝执行。

## 5.4 完整性约束命名子句

- 完整性约束命名子句

  CONSTRAINT<完整性约束条件名>

  <完整性约束条件><完整性约束条件>包括NOT NULL、UNIQUE、PRIMARY KEY、FOREIGN KEY、CHECK短语等。

- 修改表中的完整性限制

  使用ALTER TABLE语句修改表中的完整性限制

## 5.5 域中的完整性限制

> 域是一组具有相同数据类型的值的集合，即属性的取值范围。SQL可以用CREATE DOMAIN语句建立一个域以及域应该满足的完整性约束条件，然后用域定义属性。 

## 5.6 断言

1. 创建断言的语句格式

   CREATE ASSERTION<断言名><CHECK子句>

   每个断言都被赋予一个名字，<CHECK子句>中的约束条件与WHERE子句的条件表达式类似。

2. 删除断言的语句格式

   DROP ASSERTION<断言名>；

   如果断言很复杂，则系统在检测和维护断言上的开销较高，这是在使用断言时应该注意的。

## 5.7 触发器

> 触发器(trigger）是用户定义在关系表上的一类由事件驱动的特殊过程。

- 说明
  - 触发器保存在数据库服务器中。
  - 任何用户对表的增、删、改操作均由服务器自动激活相应的触发器。
  - 触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力。

### 5.7. 1 定义触发器

触发器又叫做事件一条件-动作（event-condition-action）规则。

- 语句格式

  ```sql
  CREATE TRIGGER<触发器名>
  /*每当触发事件发生时，该触发器被激活*/
  (BEFORE|AFTER}<触发事件>ON<表名>
  /*指明触发器激活的时间是在执行触发事件前或后*/
  /*REFERENCING指出引用的变量*/
  REFERENCING NEWOLD ROW AS<变量>
  /*定义触发器的类型，指明动作体执行的频率*/
  FOR EACH(ROW|STATEMENT)
  [WHEN<触发条件>]<触发动作体>
  /*仅当触发条件为真时才执行触发动作体*/
  
  ```

- 语法说明

  - 只有表的拥有者，即创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器。

  - 触发器名

    - 触发器名可以包含模式名，也可以不包含模式名。同一模式下，触发器名必须是唯一的，并且触发器名和表名必须在同一模式下。

  - 表名

    - 触发器只能定义在基本表上，不能定义在视图上。当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器，因此该表也称为触发器的目标表。

  - 触发事件

    - INSERT、DELETE或UPDATE也可以是这几个事件的组合。

    - UPDATE OF<触发列，…>，即进一步指明修改哪些列时激活触发器

    - AFTER/BEFORE是触发的时机。

      AFTER表示在触发事件的操作执行之后激活触发器。

      BEFORE表示在触发事件的操作执行之前激活触发器。

  - 触发器类型

    - 行级触发器（FOR EACH ROW）和语句级触发器（FOR EACHSTATEMENT)

  - 触发条件

    - 触发器被激活时，只有当触发条件为真时触发动作体才执行，否则触发动作体不执行。如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行。

  - 触发动作体

    - 触发动作体可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用。
    - 如果是行级触发器，用户都可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值。
    - 如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用。
    - 如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化。
    - 注意：不同的RDBMS产品触发器语法各部相同。

### 5.7.2 激活触发器

触发器的执行，是由触发事件激活的，并由数据库服务器自动执行。一个数据表上可能定义了多个触发器，遵循如下的执行顺序；

1. 执行该表上的BEFORE触发器；
2. 激活触发器的SQL语句；
3. 执行该表上的AFTER触发器。

### 5.7.3 删除触发器

删除触发器的SQL语法如下：

```sql
DROP TRIGGER<触发器名>ON<表名>；
```

触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除。

# 第六章 关系数据库理论

## 6.1 问题的提出

- 关系模式的表示

  关系模式由五部分组成，是一个五元组：R（U，D，DOM，F）。（1

  - 关系名R是符号化的元组语义。
  - U为一组属性。
  - D为属性组U中的属性所来自的域。
  - DOM为属性到域的映射。
  - F为属性组U上的一组数据依赖。

- 说明

  - 由于D、DOM与模式设计关系不大，因此在本章中把关系模式看作一个三元组：R<U,F>
  - 当且仅当U上的一个关系r满足F时，r称为关系模式R<U，F>的一个关系。
  - 作为一个二维表，关系要符合一个最基本的条件：每一个分量必须是不可分的数据项。满足了这个条件的关系模式就属于第一范式（1NF）。

- 数据依赖

  数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相互联系。

  - 数据依赖的主要类型：
    - 函数依赖（Functional Dependency,简记为FD)。
    - 多值依赖（Mu!ti-Valued Dependency,简记为M
  - 问题
    - 数据冗余
    - 更新异常
    - 插入异常
    - 删除异常

## 6.2 规范化

### 6.2.1 函数依赖

​	定义6.1设R（U)是属性集U上的关系模式，X，Y是U的子集。若对于R（U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X→Y。

- 术语和记号

  - X$\rightarrow$Y，但Y$\nsubseteq$X，则称X$\rightarrow $Y是非平凡的函数依赖。

  - X→Y，但Y$\subseteq$X，则称X→Y是平凡的函数依赖。

    对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。若不特别声明，总是讨论非平凡的函数依赖。·

  - 若X→y，则X称为这个函数依赖的决定属性组，也称为决定因素(determinant)。
  - 若X→Y，Y→X，则记作X$\leftarrow \rightarrow$Y。
  - 若Y不函数依赖于X，则记作X→Y。

------

![Snipaste_2023-08-03_09-06-33](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_09-06-33.png)

------

![Snipaste_2023-08-03_09-07-12](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_09-07-12.png)

### 6.2.2 码

![Snipaste_2023-08-03_09-21-45](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_09-21-45.png)

------

![Snipaste_2023-08-03_09-24-56](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_09-24-56.png)

### 6.2.3 范式

​	关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。满足最低要求的叫第一范式，简称1NF；在第一范式中满足进一步要求的为第二范式，其余以此类推。

![Snipaste_2023-08-03_09-27-34](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_09-27-34.png)

- 规范化
  - 一个低一级范式的关系模式通过模式分解(schemadecomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化(normalization)。

### 6.2.4 2NF

- 若RE$\in$NF，且每一个非主属性完全函数依赖于任何一个候选码，则RE$\in $2NF。
- 一个关系模式R不属于2NF，就会产生以下几个问题：
  - 插入异常
  - 删除异常
  - 修改复杂
- 解决方法：
  - 用投影分解把关系模式S-L-C分解成两个关系模式。

### 6.2.5 3NF

![Snipaste_2023-08-03_09-35-13](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_09-35-13.png)

> 不能存在传递依赖

### 6.2.6 BCNF

![Snipaste_2023-08-03_09-37-33](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_09-37-33.png)

- 由BCNF的定义可以得到结论，一个满足BCNF的关系模式有：
  - 所有非主属性对每一个码都是完全函数依赖。
  - 所有主属性对每一个不包含它的码也是完全函数依赖。
  - 没有任何属性完全函数依赖于非码的任何一组属性。

### 6.2.7 多值依赖

![Snipaste_2023-08-03_16-26-36](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_16-26-36.png)

![Snipaste_2023-08-03_16-54-34](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_16-54-34.png)

- 多值依赖的性质
  - 多值依赖具有对称性：若x→→Y，则X→→Z，其中
    Z=U-X-Y
  - 多值依赖具有传递性：若X→→Y，Y→→Z，则X→→Z-Y。
  - 函数依赖是多值依赖的特殊情况：若x→Y，则 X→→Y。
  - 若x→→Y，X→→Z，则x→→YZ。
  - 若x→→Y，X→→Z，则X→→Y$\cap$Z。
  - 若X→→Y,X→→Z，则X→→Y-Z，X→→Z-Y。
- ![Snipaste_2023-08-03_17-20-05](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_17-20-05.png)

### 6.2.8 4NF

![Snipaste_2023-08-03_17-21-57](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_17-21-57.png)

- 说明
  - 4NF是限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。4NF所允许的非平凡多值依赖实际是函数依赖。
  - 如果一个关系模式是4NF，则必为BCNF。
  - 在关系WSC中，W→→S，W→→C，他们都是非平凡多值依赖。而W不是码,关系模式WSC的码是（W,S,C),即AlI-key,因此WSC4NF。可以把WSC分解成WS（W,S)，WC（W,C)，WSE4NF，WCE4NF。

### 6.2.9 小结

![Snipaste_2023-08-03_17-24-41](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-03_17-24-41.png)

## 6.3 数据依赖的公理系统

![Snipaste_2023-08-06_09-30-35](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-06_09-30-35.png)

![Snipaste_2023-08-06_09-31-37](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-06_09-31-37.png)

![Snipaste_2023-08-06_09-37-15](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-06_09-37-15.png)

![Snipaste_2023-08-06_09-51-56](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-06_09-51-56.png)

定理6.2 Armstrong公理系统是有效的、完备的。

![Snipaste_2023-08-06_10-01-16](D:/%E6%A1%8C%E9%9D%A2/Snipaste_2023-08-06_10-01-16.png)

![Snipaste_2023-08-06_10-01-29](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-06_10-01-29.png)

- 定理6.3
  - 每一个函数依赖集F均等价于一个极小函数依赖集$F_m$。此$F_m $称为F的最小依赖集。

## 6.4 模式的分解

![Snipaste_2023-08-06_10-17-23](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-06_10-17-23.png)

### 6.4.1 模式分解的三个定义

- 对于一个模式的分解是多种多样的，但是分解后产生的模式应与原模式等价。
  - 等价 
    - 分解具有无损连接性（lossless join）。
    - 分解要保持函数依赖(preserve functional dependency)。
    - 分解既要保持函数依赖，又要具有无损连接性。

# 第七章 数据库设计

## 7.1 数据库设计概念

1. 数据库设计定义
   - 数据库设计是指对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。 
2. 信息管理要求
   - 在数据库中应该存储和管理那些数据对象
3. 数据操作要求
   - 对数据对象需要进行那些操作，如查询，增，删，改，统计等操作
4. 数据库设计的目标
   - 为用户和各种应用系统提供一个信息基础设施和高效的运行环境。
5. 高效的运行环境
   1. 数据库数据的存取效率高
   2. 数据库存储空间的利用率高
   3. 数据库系统运行管理的效率高

### 7.1.1 数据库设计的特点

1. 数据库建设的基本规律
   - 三分技术，七分管理，十二分基础数据
   - 管理
     - ​	数据库建设项目管理和企业（应用部门）的业务管理
   - 基础数据
     - 数据的收集，整理，组织和不断更新
2. 结构(数据)设计和行为(处理)设计相结合

### 7.1.2 数据库设计方法

大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。它要求从事数据库设计的专业人员具备多方面的知识和技术。主要包括：

- 计算机的基础知识；·
- 软件工程的原理和方法；
- 程序设计的方法和技巧；
- 数据库的基本知识；
- 数据库设计技术；
- 应用领域的知识。



1. 手工与经验结合的方法
   - 存在的问题
     - 设计质量与设计人员的经验和水平有直接关系。
     - 缺乏科学理论和工程方法的支持，工程的质量难以保证
     - 数据库运行一段时间后常常又不同程度地发现各种问题，增加了维护代价。
2. 规范设计法
   1. 基本思想：过程迭代和逐步求精
   2. 典型方法
      1. 新奥尔良（New Orleans）方法）
      2. 基于E-R模型的数据库设计方法）
      3. 3NF（第三范式）的设计方法
      4. 面向对象的数据库设计方法
      5. 统一建模语言（UML）方法

### 7.1.3 数据库设计的基本步骤

数据库设计阶段

- 需求分析；
- 概念结构设计；
- 逻辑结构设计；
- 物理结构设计；
- 数据库实施；
- 数据库运行和维护。

> - 需求分析和概念结构设计可以独立于任何数据库管理系统进行，
> - 逻辑结构设计和物理结构设计与选用的数据库管理系统密切相关。

![Snipaste_2023-07-29_11-57-13](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-29_11-57-13.png)

- 参加数据库设计的人员
  - 系统分析人员和数据库设计人员：
    - 自始至终参与数据库设计，其水平决定了数据库系统的质量。
  - 数据库管理员和用户代表：
    - 要参加需求分析与数据库的运行和维护。
  - 应用开发人员：
    - 包括程序员和操作员，在实施阶段参与进来，分别负责编制程序和准备软硬件环境。
- 各阶段的主要任务
  -   需求分析阶段：
    - 了解用户需求，该阶段是否做得充分与准确，决定了构建数据库的速度和质量。
  - 概念结构设计阶段：
    - 对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型
  - .逻辑结构设计阶段：
    - 将概念结构转换为数据库管理系统所支持的数据模型，并对其进行优化。
  - 物理结构设计阶段：
    - 逻辑数据结构选取一个最合应用环境的物理结构，包括存储结构和存取方法。
  - 5.数据库实施阶段：
    - 根据逻辑设计和物理设计的结果构建数据库，编写与调试应用程序，组织数据入库并进行试运行。
  - 数据库运行和维护阶段：
    - 经过试运行后即可投入正式运行，在运行过程中必须不断对其进行评估、调整与修改。

- 各个阶段的数据设计描述

![Snipaste_2023-07-29_12-02-18](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-29_12-02-18.png)

### 7.1.4 数据库设计过程中的各级模式

![Snipaste_2023-07-29_12-13-47](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-07-29_12-13-47.png)

## 7.2 需求分析

### 7.2.1 需求分析的任务

1. 详细调查现实世界要处理的对象（组织、部门、企业等）。

2. 充分了解原系统（手工系统或计算机系统）工作概况。

3. 明确用户的各种需求。

4. 确定新系统的功能，新系统必须充分考虑今后可能的扩充和改变。

   > 【说明】
   >
   > 调查的重点是“数据”和“处理”，获得用户对数据库在信息、处理、安全性与完整性的要求。

### 7.2.2 需求分析的方法

- 需求分析的目的：
  - 调查清楚用户的实际需求并进行初步分析最终与用户达成共识。
- 调查用户需求的步骤：
  - 调查组织机构情况。
  - 调查各部门的业务活动情况。
  - 协助用户明确对新系统的各种要求，包括信息要求、处理要求，安全性与完整性要求。
  - 确定新系统的边界。
- 常用的调查方法有：
  - 跟班作业。通过亲身参加业务工作来了解业务活动的情况。
  - 开调查会。通过与用户座谈来了解业务活动情况及用户需求。
  - 请专人介绍。
  - 询问。对某些调查中的问题可以找专人询问。
  - 设计调查表请用户填写。如果调查表设计得合理，这种方法是很有效的。
  - 查阅记录。查阅与原系统有关的数据记录。

### 7.2.3 数据字典

数据字典是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善的。它在数据库设计中占有很重要的地位。

------

数据字典

- 数据项
  - 是不可在分的数据单位
  - 数据项描述={数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系}
  - 其中，“取值范围”、“与其他数据项的逻辑关系”（如该数据项等于其他几个数据项的和、该数据项值等于另一数据项的值等)定义了数据的完整性约束条件，是设计数据检验功能的依据。
  - 可以用关系规范化理论为指导，用数据依赖的概念分析和表示数据项之间的联系。
- 数据结构
  - 反映了数据之间的组合关系
  - 数据结构描述={数据结构名，含义说明，组成：{数据项或数据结构}}
  - 一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。
- 数据流
  - 是数据结构在系统内传输的路径。
  - 数据流描述={数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}
  - 数据流来源：
    - 是说明该数据流来自哪个过程；
  - 数据流去向：
    - 是说明该数据流将到哪个过程去；
    - 平均流量：
      - 是指在单位时间（每天、每周、每月等）里的传输次数；
    - 高峰期流量：
      - 则是指在高峰时期的数据流量。
- 数据存储
  - 是数据结构停留或保存的地方，也是数据流的来源和去向之一
  - 数据存储描述={数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存取频度，存取方式}
  - 存取频度：
    - 指每小时、每天或每周存取次数及每次存取的数据量等信息；
  - 存取方式：
    - 指是批处理还是联机处理、是检索还是更新、是顺序检索还是随机检索等；
  - 输入的数据流：
    - 数据来源；
  - 输出的数据流：
    - 数据去向。
- 处理过程
  - 处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明性信息即可
  - 处理过程描述={处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}
  - “简要说明”说明该处理过程的功能及处理要求。其中功能是指该处理过程用来做什么。处理要求是指处理频度要求，如单位时间里处理多少事务，多少数据量、响应时间要求等。

## 7.3 概念结构设计

### 7.3.1 概念模型

概念结构设计是将需求分析得到的用户需求抽象为信息结构（即概念模型）的过程

- 概念模型的特点
  - 能真实、充分地反映现实世界，是现实世界的一个真实模型。
  - 易于理解，可以用它和不熟悉计算机的用户交换意见。
  - 易于更改，当应用环境和应用要求改变时容易对概念模型修改和扩充。
  - 易于向关系、网状、层次等各种数据模型转换。

### 7.3.2 E-R模型

- E-R图
  - E-R图提供了表示实体型，属性和联系的方法
  - 实体型
    - 用矩形表示，矩形框内写明实体名
  - 属性
    - 用椭圆形表示，并用无向边将其与相应的实体型连接起来
  - 联系
    - 用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1：1、1:n或m:n)。

### 7.3.3 扩展的E-R模型

1. 分类属性
   1. 根据分类属性的值把父实体型中的实体分派到子实体型中。 
2. 不相交约束与可重叠约束
   1. 不相交约束
      - 父类中的一个实体不能同时属于多个子类中的实体集，即一个父类中的实体最多属于一个子类实体集。用ISA联系三角形符号内加一个“x”来表示。
   2. 可重叠约束
      - 父类中的一个实体能同时属于多个子类中的实体集，三角形符号内没有“X”来表
   3. 完备性约束
      - 完备性约束描述父类中的一个实体是否必须是某一个子类中的实体，如果是，则叫做完全特化(total specialization)，否则叫做部分特化(partial specialization)。
      - 完全特化用父类到子类的双线连接来表示，单线连接则表示部分特化。
   4. 基数约束
      - 基数约束是对实体之间一对一、一对多和多对多联系的细化。
      - 参与联系的每个实体型用基数约束来说明实体型中的任何一个实体可以在联系中出现的最少次数和最多次数。
      - 约束用一个数对min..max表示，0≤min≤max。
      - min=1的约束叫做强制参与约束，即被施加基数约束的实体型中的每个实体都要参与联系。
      - min=0的约束叫做非强制参与约束，即被施加基数约束的实体可以出现在联系中，也可以不出现在联系中。

1. ISA联系 
   - 用E-R方法构建一个项目的模型时，经常会遇到某些实体型是某个实体型的子类型。例如，研究生和本科生是学生的子类型，学生是父类型。这种父类-子类联系称为ISA联系，表示“is a”的语义。例如，图7.12中研究生is a学生，本科生is a学生。ISA联系用三角形来表示。
2. Part-of联系
   - 即部分联系，表明某个实体型是另外一个实体型的一部分。
   - 非独占的Part-of联系：
     - 整体实体如果被破坏，部分实体仍然可以独立存在。非独占的Part-of联系可以通过基数约束 ，来表达。
   - 独占的Part-of联系：
     - 实体如果被破坏，部分实体不能存在。在E-R图中用弱实体类型和识别联系来表示独占联系。
     - 如果一个实体型的存在依赖于其他实体型的存在，则这个实体型叫做弱实体型，否则叫做强实体型。
     - 判断方法：如果不能从一个实体型属性中找出可以作为码的属性，这个实体型是弱实体型。
     - 在E-R图中用双矩形表示弱实体型，用双菱形表示识别联系。

### 7.3.4 UML

UML表示E-R图的说明

- ·实体型：
  - 用类表示，矩形框中实体名放在上部，下面列出属性名。·
- 实体的码：
  - 在类图中在属性后面加“PK”（primary key）来表示码属性。·
- 联系：
  - 用类图之间的“关联”来表示。

### 7.3.5 概念结构设计

概念结构设计的第一步就是对需求分析阶段收集到的数据进行分类、组织，确定实体、实体的属性、实体之间的联系类型，形成E-R图。

- 实体与属性的划分原则

  - 为了简化E-R图的处置，现实世界的事物能作为属性对待的尽量作为属性对待。

- 两条准则

  - 作为属性，不能再具有需要描述的性质，即属性必须是不可分的数据项，不能包含其他属性。
  - 属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。

- E-R图的集成

  - E-R图 的集成一般需要分两步
    - 合并
      - 解决各分E-R图之间的冲突，将分E-R图合并来生成初步E-R图。
    - 修改和重构。
      - 消除不必要的冗余，生成基本E-R图

- 冲突 

  - 属性冲突
    - 属性域冲突，即属性值的类型、取值范围或取值集合不同。
    - 属性取值单位冲突
  - 命名冲突
    - 同名异义
    - 异名同义(一义多名)
    - 命名冲突
  - 结构冲突
    - 同一对象在不同应用中具有不同的抽象
      - 解决方法通常是把属性变换为实体或把实体变换为属性，使同一对象具有相同的抽象。但变换时仍要遵循7.3.5小节中讲述的两个准则。
    - ·同一实体在不同子系统的E-R图中所包含的属性个数和属性排列次序不完全相同。
      - 原因是不同的局部应用关心的是该实体的不同侧面。
      - 解决方法是使该实体的属性取各子系统的E-R图中属性的并集，再适当调整属性的次序。·
    - 实体间的联系在不同的E-R图中为不同的类型。
      - 解决方法是根据应用的语义对实体联系的类型进行综合或调整。

- 消除不必要的冗余，设计基本E-R图

  - 所谓冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系。
  - 消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。
  - 但并不是所有的冗余数据与冗余联系都必须加以消除，有时为了提高效率，不得不以冗余信息作为代价。

- 用规范化理论来消除冗余

  - 确定分E-R图实体之间的数据依赖。

  - $求FL的最小覆盖G_L，差集为D=F_z-G_L。$

  - > 冗余的联系一定在D中，而D中的联系不一定是冗余的。
    >
    > 当实体之间存在多种联系时，要将实体之间的联系在形式上加以区分。

- 集成过程需解决以下问题

  - 异名同义
  - 取消冗余联系

## 7.4 逻辑结构设计

- 逻辑结构设计的任务
  - 是把概念结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。

### 7.4.1 E-R图向关系模型的转换

E-R图向关系模型的转换就是将实体型、实体的属性和实体型之间的联系转化为关系模式。

- 转换原则
  - 一个实体型转换为一个关系模式，关系的属性就是实体的属性，关系的码就是实体的码。
- 实体间的联系
  - 一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。
    - 转换为一个独立的关系模式
      - 关系的属性：与该联系相连的各实体的码及联系本身的属性
      - 关系的候选码：每个实体的码均是该关系的候选码
    - 与某一端实体 对应的关系模式合并
      - 合并后关系的属性：加入对应关系的码和联系本身的属性
      - 合并后关系的码：不变
  - 一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并
    - 转换为一个独立的关系模式
      - 关系的属性：与该联系相连的各实体的码和联系本身的属性
      - 关系的候选码：n端实体的码
    - 与n端对应的关系模式合并
      - 合并后的关系属性：在n端关系中加入1端关系的码和联系本身的属性
      - 合并后关系的码：不变
  - 一个m:n联系转换为一个关系模式
    - 关系的属性：与该联系相连的各实体的码及联系本身的属性
    - 关系的候选码：各实体码的组合
  - 三个或三个以上实体间的一个多元联系转换为一个关系模式。
    - 关系的属性：与该联系相连的各实体的码及联系本身的属性。
    - 关系的候选码：各实体码的组合。
  - 具有相同码的关系模式可合并。
    - 目的：减少系统中的关系个数。
    - 合并方法：
      - 第一步：将其中一个关系模式的全部属性加入到另一个关系模式中。
      - 第二步：去掉其中的同义属性（可能同名也可能不同名）
      - 第三步：适当调整属性的次序。

### 7.4.2 数据模型的优化

​	数据库逻辑设计的结果不是唯一的。为了进一步提高数据库应用系统的性能，还应该根据应用需要适当地修改、调整数据模型的结构，这就是数据模型的优化。

- 优化数据模型的优化

  1. 确定数据依赖。按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间的数据依赖。

  2. 对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系

  3. 按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。

  4. 根据需求分析阶段得到的处理要求分析对于这样的应用环境这些模式是否合适，确定是否要对某些模式进行合并或分解。

     > 必须注意的是，并不是规范化程度越高的关系就越优。

  5. 对关系模式进行必要分解，提高数据操作效率和存储空间利用率。常用的两种分解方法是水平分解和垂直分解。

     1. 水平分解
        - 把(基本)关系的元组分为若干子集合，定义每个子集合为一个子关系
        - 分解方法
          - 对符合80/20原则的，把经常使用的数据（约20%）水平分解出来，形成一个子关系。
          - 是使每个事务存取的数据对应一个子关系。
        - 垂直分解
          - 把关系模式R的属性分解为若干子集合，形成若若干子关系模式。
          - 分解原则：经常在一起使用的属性从R中分解出来形成一个关系模式。
          - 分解优点：可以提高某些事务的效率。
          - 分解缺点：可能使另一些事务不得不执行连接操作，降低了效率。
          - 适用范围：取决于分解后R上的所有事务的总效率是否得到了提高。
          - 分解方法：
            - 简单情况直观分解。
            - 复杂情况用第6章中的模式分解算法。
            - 垂直分解必须不损失关系模式的语义（保持无损连接性和保持函数依赖）。

### 7.4.3 设计用户子模式

​	定义数据库全局模式主要是从系统的时间效率、空间效率、易维护等角度出发。

​	定义用户外模式时可以注重考虑用户的习惯与方便。

- 使用更符合用户习惯的别名
- 针对不同级别的用户定义不不同的视图，以保证系统的安全性
- 简化用户对系统的使用

## 7.5 物理结构设计

> 数据库在物理设备上的存储结构与存取方法称为数据库的物理结构，它依赖于选定的数据库管理系统。
>
> 为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是物理结构设计 

设计步骤

- 确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构。
- 对物理结构进行评价，评价的重点是时间和空间效率。

### 7.5.1 数据库物理设计的内容和方法

- 所需参数

  - 对于数据库查询事务，需要得到如下信息：
    - ·查询的关系。
    - 查询条件所涉及的属性。
    - 连接条件所涉及的属性。
    - 查询的投影属性。

  - 对于数据更新事务，需要得到如下信息：
    - 被更新的关系。
    - 每个关系上的更新操作条件所涉及的属性。
    - 修改操作要改变的属性值。
  - 每个事务在各关系上运行的频率和性能要求

- 通常关系数据库物理设计的内容主要包括为

  - 关系模式选择存取方法，以及设计关系、索引等数据库文件的物理存储结构。

### 7.5.2 关系模式存取方法选择

- 常用存取方法
  - B+树索引存取方法
    1. 如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）。
    2. 如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引。
    3. 如果一个(或一组)属性经常在连接操作的连接条件中出现，则考虑在这个(或这组)属性上建立索引。
  - hash索引存取方法的选择
    - 选择hash存取方法的规则如下：如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一，则此关系可以选择hash存取方法。
      - 一个关系的大小可预知，而且不变。
      - 关系的大小动态改变，但数据库管理系统提供了动态hash存取方法。
  - 聚簇存取方法的选择
    - 为了提高某个属性(或属性组）的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇。该属性(或属性组）称为聚簇码(cluster key)。
    - 聚簇对于某些类型的查询，可以提高查询效率。
    - 在一个基本表上最多只能建立一个聚簇索引。
    - 聚簇索引的适用条件，
      - 一是很少对基表进行增删操作，
      - 二是很少对其中的变长列进行修改操作。
    - 选择聚簇存取方法
      - 设计候选聚簇
        - 对经常在一起进行连接操作的关系可以建立聚簇。如果一个关系的一组属性经常出现在相等比较条件中，则该单个关系可建立聚簇。如果一个关系的一个(或一组)属性上的值重复率很高，则此单个关系可建立聚簇
      - 检查候选聚簇中的关系，取消其中不必要的关系
        - 从聚簇中删除经常进行全表扫描的关系。
        - 从聚簇中删除更新操作远多于连接操作的关系。
        - 从聚簇中删除重复出现的关系，当一个关系同时加入多个聚簇时，必须从这多个聚簇方案(包括不建立聚簇)中选择一个较优的，即在这个聚簇上运行各种事务的总代价最小。

### 7.5.3 确定数据库的存储结构

> ​	确定数据库物理结构主要指确定数据的存放位置和存储结构，包括确定关系、索引、聚簇、日志、备份等的存储安排和存储结构，确定系统配置等。
>
> ​	确定数据的存放位置和存储结构要综合考虑存取时间、存储空间利用率和维护代价三方面的因素。这三个方面常常是相互矛盾的，因此需要进行权衡，选择一个折中方案。

- 确定数据的存放位置
  - 为了提高系统性能，应该根据应用情况将数据的易变部分与稳定部分、经常存取部分和存取频率较低部分分开存放。
- 确定系统配置

### 7.5.4 评价物理结构

​	对数据库物理设计过程中产生的多种方案进行评价，从中选择一个较优的方案作为数据库的物理结构。评

​	价方法主要是定量估算各种方案的存储空间、存取时间、维护代价，对估算结果进行权衡、比较，选择出一个较优的合理的物理结构。

## 7.6 数据库的实施和维护

### 7.6.1数据的载入和应用程序的调试

- 数据载入方法
  - 人工方法
  - 计算机辅助数据入库
- 应用程序的调试

### 7.6.2 数据库的试运行

​	应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试，也称数据库的试运行。

- 主要工作
  - 功能测试
  - 性能测试

### 7.6.3 数据库的运行和维护

主要工作

- 数据库的转储和恢复
- 数据库的安全性和完整性控制
- 数据库性能的监督，分析和改造
- 数据库的重组织与重构造

# 第八章 数据库编程

## 8.1 嵌入式SQL

### 8.1.1 嵌入式SQL的处理过程

​	嵌入式SQL语句中可以使用主语言的程序变量来输入或输出数据。SQL语句中使用的主语言程序变量简称为**主变量**。

- 输入主变量
  - 由应用程序对其赋值，SQL语句引用；
- 输出主变量
  - 由SQL语句对其赋值或设置状态信息，返回给应用程序。
- 指示变量
  - 是一个整型变量，用来“指示”所指主变量的值或条件。指示变量可以指示输入主变量是否为空值，可以检测输出主变量是否为空值，值是否被截断。

# 第九章 关系查询处理和查询优化

## 9.1 关系数据库系统的查询处理

### 9.1.1 查询处理步骤

1. 查询分析

   对查询语句进行扫描、词法分析和语法分析，

   - 词法分析：从查询语句中识别出正确的语言符号。
   - 语法分析：进行语法检查。

2. 查询检查

   - 合法性检查
   - 视图转换
   - 安全性和完整性初步检查

3. 查询优化

   查询优化即选择一个高效执行的查询处理策略。

   - 代数优化/逻辑优化
     - 指关系代数表达式的优化，即按照一定的规则，通过对关系代数表达式进行等价变换，改变代数表达式中操作的次序和组合，使查询执行更高效；
   - 物理优化
     - 指存取路径和底层操作算法的选择。
   - 查询优化的选择依据
     - 基于规则
     - 基于代价
     - 基于语义

   ![Snipaste_2023-08-10_13-19-16](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-10_13-19-16.png)

- 查询执行

### 9.1.2 实现查询操作的算法示例

- 选择操作的典型实现
  - 全表扫描方法（Table Scan）
    - 对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出。该方法适合小表，不适合大表。
    - 假设可以使用的内存为M块，全表扫描的算法思想如下：
      1. 按照物理次序读Student的M块到内存。
      2. 检查内存的每个元组t，如果t满足选择条件，则输出t。
      3. 如果Student 还有其他块未被处理，重复1和2。
  - 索引扫描方法（Index Scan）
    - 适合于选择条件中的属性上有索引（例如B+树索引或Hash索引），通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组。
- 连接操作的实现
  - 最耗时的操作
  - 常用算法
    - 嵌套循环算法（nestec 1oop join）
      1. 对外层循环（Student表）中的每一个元组（sc），检索内层循环（SC表）中的每一个元组（sc）；
      2. 检查这两个元组在连接属性（Sno）上是否相等；
      3. 如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止。
    - 排序-合并算法（sort-merge join或merge join）
      1.  如果参与连接的表没有排好序，首先对Student表和SC表按连接属性Sno 排序。
      2. 取Student表中第一个Sno,依次扫描SC表中具有相同Sno的元组，把它们连接起来
      3. 当扫描到Sno不相同的第一个SC元组时，返回Student表扫描它的下一个元组，再扫描SC表中具有相同Sno的元组，把它们连接起来
    - 索引连接(index join）算法
      1. 在SC表上已经建立了属性Sno的索引。
      2. 对Student中每一个元组，由Sno值通过SC的索引查找相应的SC元组。
      3. 把这些SC元组和Student元组连接起来。
      4. 循环执行②③，直到Student表中的元组处理完为止。
    - Hash Join算法

## 9.2 关系数据库系统的查询处理

### 9.2.1 查询优化概述

$$
总代价 = I/O代价 + CPU代价+内存代价+通信代价 
$$

计算查询代价时一般用查询处理读写的块数作为衡量单位。

## 9.3 代数优化

### 9.3.1 关系代数表达式等价变换规则

代数优化策略是通过对关系代数表达式的等价变换来提高查询效率。

- 连接，笛卡儿积的交换律
  - 设$E_1$和$E_2$是关系代数表达式，F是连接运算的条件
    - $E_1 \times E_2 \equiv E_2 \times E_1$
    - $E_1 \bowtie E_2 \equiv E_2 \bowtie E_1$
    - $E_1 \underset{F}{\bowtie} E_2 \equiv E_2 \underset{F}{\bowtie} E_1$

- 连接，笛卡儿积的结合律

  P281

### 9.3.2 查询树的启发式优化

典型的启发式规则

1. 选择运算应尽可能先做。
   - 在优化策略中这是最重要、最基本的一条。它常常可使执行代价节约几个数量级，因为选择运算一般使计算的中间结果大大变小。
2. 把投影运算和选择运算同时进行。
   - 如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有这些运算以避免重复扫描关系。
3. 把投影同其前或后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系。
4. 把某些选择同在它前面要执行的笛卡儿积结合起来成为一个连接运算，连接(特别是等值连接）运算要比同样关系上的笛卡儿积省很多时间。
5. 找出公共子表达式。
   - 如果这种重复出现的子表达式的结果不是很大的关系，并且从外存中读入这个关系比计算该子表达式的时间少得多，则先计算一次公共子表达式并把结果写入中间文件是合算的。当查询的是视图时，定义视图的表达式就是公共子表达式的

![Snipaste_2023-08-10_16-30-39](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-10_16-30-39.png)

## 9.4 物理优化

物理优化就是要选择高效合理的操作算法或存取路径，求得优化的查询计划，达到查询优化的目标。选择的方法可以是：

1. 基于规则的启发式优化。
   - 启发式规则是指那些在大多数情况下都适用，但不是在每种情况下都是最好的规则。
2. 基于代价估算的优化。
   - 使用优化器估算不同执行策略的代价，并选出具有最小代价的执行计划。
3. 两者结合的优化方法。
   - 查询优化器通常会把这两种技术结合在一起使用。因为可能的执行策略很多，要穷尽所有的策略进行代价估算往往是不可行的，会造成查询优化本身付出的代价大于获得的益处。为此，常常先使用启发式规则，选取若干较优的候选方案，减少代价估算的工作量；然后分别计算这些候选方案的执行代价，较快地选出最终的优化方案。

### 9.4.1 基于启发式规则的存取路径选择优化

P284

### 9.4.2 基于代价估算的优化

# 第十章 数据库恢复技术

## 10.1 事务的基本概念

- 事务
  - 事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。例
  - 事务的特性（ACID特性（ACID properties））
    - 原子性（Atomicity）
      - 事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。
    - 一致性（Consistency）
      - 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。
      - 一致性状态：数据库中只包含成功事务提交的结果。
      - 不一致状态：数据库系统运行中发生故障，有些事务尚未完成就被迫中断；这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种工确的状态。
    - 隔离性（Isolation）
      - 一个事务的执行不能被其他事务干扰。即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
    - 特续性（Durability）
      - 持续性也称永久性(Permanence)，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。
  - 保证事务ACID特性是事务管理的重要任务。事务ACID特性可能遭到破坏的因素有：
    - 多个事务并行运行时，不同事务的操作交叉执行；
    - 事务在运行过程中被强行停止。

## 10.2 数据库恢复概述

- 故障是不可避免的，故障主要包括：
  - 计算机硬件故障、软件的错误、操作员的失误、恶意的破坏等。
- 故障对数据库的影响主要表现为：
  - 运行事务非正常中断、影响数据库中数据的正确性、数据库全部或部分丢失数据等。
- 数据库恢复的作用：
  - 把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能。

## 10.3 故障的种类

- 事务内部的故障
  - 事务内部的故障有的是可以通过事务程序本身发现的，有的是非预期的，不能由事务程序处理。
  - 事务内部更多的故障是非预期的，是不能由应用程序处理的
- 系统故障
  - 指造成系统停止运转的任何事件，使得系统要重新启动
  - 系统故障的恢复
    - 表现一：发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。
    - 恢复策略：系统重新启动时，恢复程序让所有非正常终止的业务回滚，强行撤消（UNDO）所有未完成事务。
    - 表现二：发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失。
    - 恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务。
- 介质故障
  - 介质故障称为硬故障，指外存故障，如磁盘损坏、磁头碰撞、瞬时强磁场干扰等。
  - 故障表现：
    - 破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务，介质故障比前两类故障的可能性小得多。，但破坏性大得多
- 计算机病毒
  - 计算机病毒是一种可繁殖、传播并对计算机造成破坏的计算机程序。
  - 计算机病毒的特点：
    - 隐蔽性
    - 潜伏性
    - 传染性
    - 破坏性
    - 破坏性
    - 寄生性
  - 数据库一旦被病毒破坏仍要用恢复技术把数据库加以恢复。

## 10.4 恢复的实现技术

- 恢复机制涉及的两个关键问题是：
  - 如何建立冗余数据
  - 以及如何利用这些冗余数据实施数据库恢复。
  - 建立冗余数据最常用的技术是
    - 数据转储
    - 登记日志文件（logging）

### 10.4.1 数据存储

> 数据转储是数据库恢复中采用的基本技术。所谓转储即数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程。这些备用的数据称为后备副本（backup）或后援副本。
>
>  
>
> 后备副本只能将数据库恢复到转储时的状态，要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务。

![Snipaste_2023-08-16_07-22-01](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-16_07-22-01.png)

- 存储方法
  - 静态存储
    - 在系统中无运行事务时进行的转储操作，即转储期间不允许对数据库进行任何存取、修改活动。
    - 优点：
      - 实现简单。
    - 缺点：
      - 降低了数据库的可用性，因为转储必须等待正运行的用户事务结束，新的事务必须等转储结束。
  - 动态存储
    - 转储操作与用户事务并发进行，转储期间允许对数据库进行存取或修改。
    - 优点
      - 不用等待正在运行的用户事务结束，不会运行影响事务的运行
    - 缺点：
      - 不能保证副本中的数据正确有效。
  - 海量转储
    - 每次转储全部数据库
  - 增量转储
    - 只转储上次转储后更新过的数据

![Snipaste_2023-08-16_07-29-09](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-16_07-29-09.png)

### 10.4.2 登记日志文件

1. 日志文件的格式和内容

   日志文件是用来记录事务对数据库的更新操作的文件

   1. 日志文件的格式

      以记录为单位的日志文件和以数据块为单位的日志文件两种

      - 以记录为单位的日志文件需要登记的内容：
        - 各个事务的开始标记（BEGIN TRANSACTION）；
        - 各个事务的结束标记（COMMIT或ROLLBACK）；
        - 各个事务的所有更新操作；
      - 每个日志记录的内容主要包括：
        - 事务标识(标明是哪个事务）。
        - 操作的类型(插入、删除或修改）。
        - 操作对象（记录内部标识）。
        - 更新前数据的旧值(对插入操作而言，此项为空值）。
        - 更新后数据的新值(对删除操作而言，此项为空值）。

   2. 日志文件的作用

      用于事务故障恢复和系统故障恢复，并协助后备副本进行介质故障恢复，具体为：

      - 事务故障恢复和系统故障恢复必须用日志文件。
      - 在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。
      - 在静态转储方式中也可以建立日志文件，当数据库毁坏后可重新装入后援副本把数据库恢复到转储结束时刻的正确状态，然后利用日志文件把已完成的事务进行重做处理，对故障发生时尚未完成的事务进行撤销处理。

      ![Snipaste_2023-08-16_07-34-15](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-16_07-34-15.png)

- 登记日志文件
  - 为保证数据库是可恢复的，登记日志文件时必须遵循两条原则：
    - 登记的次序严格按并发事务执行的时间次序。
    - 必须先写日志文件，后写数据库。

## 10.5 恢复策略

### 10.5.1 事务故障的恢复

- 事务故障：
  - 事务在运行至正常终止点前被终止，恢复子系统利用日志文件撤销（UND0）此事务已对数据库进行的修改。
- 事务故障的恢复步骤是：
  1. 反向扫描日志文件（即从最后向前扫描日志文件），查找该事务的更新操作。
  2. 对该事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库。
    - 插入操作，“更新前的值”为空，则相当于做删除操作。
    - 删除操作，“更新后的值”为空，则相当于做插入操作
    - 修改操作，则相当于用修改前1修改后值。
  3. 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。
  4. 如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。

### 10.5.2 系统故障的恢复

- 前面已讲过，系统故障造成数据库不一致状态的原因有两个，
    - 一是未完成事务对数据库的更新可能已写入数据库，
    - 二是已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库。

- 恢复操作就
    - 撤销故障发生时未完成的事务
    - 重做已完成的事务。

- 糸统故障的恢复步骤：

    1. 正向扫描日志文件（即从头扫描日志文件）

        找出在故障发生前已经提交的事务，加入重做队列，找出故障发生时尚未完成的事务，加入撤销队列。

    2. 对撤销队列事务进行撤销处理

        反向扫描日志文件，对每个撤销事务的更新操作执行逆操作，即将日志记录中“更新前的值”写入数据库。

    3. 对重做队列事务进行重做处理

        正向扫描日志文件，对每个重做事务重新执行登记的操作，将日志记录中“更新后的值”写入数据库。

### 10.5.3 介质故障的恢复

介质故障后磁盘上的物理数据和日志文件被破坏，这是最严重的一种故障，恢复方法是重装数据库，然后重做已完成的事务

- 恢复步骤

    1. 装入最新的后备数据库副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。

        对于静态转储的数据库副本，装入后数据库处于一致性状态

        对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。

    2. 装入相应的日志文件副本(转储结束时刻的日志文件副本），重做已完成的事务。

        首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。

## 10.6 具有检查点的恢复技术

- 解决问题

    - 一是搜索整个日志将耗费大量的时间，
    - 二是很多需要重做处理的事务实际上已经将它们的更新操作结果写到了数据库中，然而恢复子系统又重新执行了这些操作，浪费了大量时间。

- 解决方案

    - 具有检查点(checkpoint）的恢复技术，即在日志文件中增加检查点记录，增加重新开始文件，恢复子系统在登录日志文件期间动态地维护日志。

- 检查点技术 

    1. 检查点记录的内容

        1. 建立检查点时刻所有正在执行的事务清单。
        2. 这些事务最近一个日志记录的地址。
        3. 重新开始文件的内容。
        4. 记录各个检查点记录在日志文件中的地址。

        ![Snipaste_2023-08-16_15-55-14](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-16_15-55-14.png)

    2. 动态维护日志文件的方法

        周期性地执行建立检查点、保存数据库状态的操作。

        1. 将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上。
        2. 在日志文件中写入一个检查点记录。
        3. 将当前数据缓冲区的所有数据记录写入磁盘的数据库中。
        4. 把检查点记录在日志文件中的地址写入一个重新开始文件。

- 系统使用检查点方法进行恢复的步骤是：

    1. 从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。
    2. 由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。
        - 这里建立两个事务队列：
            - UNDO-LIST：需要执行UNDO操作的事务集合；·
            - REDO-LIST：需要执行REDO操作的事务集合。把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。
    3. 从检查点开始正向扫描日志文件。
        1. 如有新开始的事务T，把T；暂时放入UNDO-LIST队列；
        2. 如有提交的事务T，把T从UNDO-LIST队列移到REDO-LIST队列；直到日志文件结束。
    4. 对UNDO-LIST中的每个事务执行UNDO操作，对REDO-LIST中的每个事务执行REDO操作。

## 10.7 数据库镜像

数据库镜像：数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上，每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去，保证镜像数据与主数据的一致性。

![Snipaste_2023-08-16_16-03-53](https://noclose-image.oss-cn-hangzhou.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BASnipaste_2023-08-16_16-03-53.png)
