>**面试官**：redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）
>
>**候选人**：嗯！就说我最近做的这个项目，里面有xxxx（**根据自己的简历上写**）的功能，需要让数据库与redis高度保持一致，因为要求时效性比较高，我们当时采用的读写锁保证的强一致性。
>
>我们采用的是redisson实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。
>
>**面试官**：那这个排他锁是如何保证读写、读读互斥的呢？
>
>**候选人**：其实排他锁底层使用也是setnx，保证了同时只能有一个线程操作锁住的方法
>
>**面试官**：你听说过延时双删吗？为什么不用它呢？
>
>**候选人**：延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。
>
>
>
>**面试官**：redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）
>
>**候选人**：嗯！就说我最近做的这个项目，里面有xxxx（**根据自己的简历上写**）的功能，数据同步可以有一定的延时（符合大部分业务）
>
>我们当时采用的阿里的canal组件实现数据同步：不需要更改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据，更新缓存即可。