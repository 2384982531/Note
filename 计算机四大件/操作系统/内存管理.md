# 内存管理

# 内存管理

## 内存的基础知识

### 什么是内存，有何作用

- 存储单元，内存地址的概念和联系
- 按字节编址VS按字编制

### 进程运行的基本原理

- 指令的工作原理

  - 操作码+若干参数（可能包含地址参数）
- 逻辑地址（相对地址）VS 物理地址（绝对地址）
- 从写程序到程序运行

  - 编辑源代码文件
  - 编译

    - 由源代码文件生成目标模块（高级语言“翻译”为机器语言）
  - 链接

    - 由目标模块生成装入模块，链接后形成完整的逻辑地址
  - 装入

    - 将装入模块装入内存，装入后形成物理地址
- 三种链接方式

  - 静态链接

    - 装入前链接成一个完整装入模块
  - 装入时动态链接

    - 运行前边装入边链接
  - 运行时动态链接

    - 运行时需要目标模块才装入并链接
- 三种装入方式

  - 绝对装入

    - 编译时产生绝对地址
  - 可重定位装入（静态和动态）

    - 装入时将逻辑地址转换成为物理地址
  - 动态运行时装入

    - 运行时将逻辑地址转换为物理地址，需设置重定位寄存器

## 内存管理的概念

### 内存空间的分配与回收

### 内存空间的扩充（实现虚拟性）

### 地址转换

- 操作系统负责实现逻辑地址到物理地址的转换
- 三种方式

  - 绝对装入：编译器负责地址转换（单道程序阶段，无操作系统）
  - 可重定位装入：装入程序负责地址装换（早起多道批处理阶段）
  - 动态运行时装入：运行时才进行地址转换（现代操作系统）

### 存储保护

- 保证各进程在自己的内存空间内运行，不会越界访问
- 两种方式

  - 设置上下限寄存器
  - 利用重定位寄存器，界地址寄存器进行判断

## 覆盖与交换

### 覆盖技术

- 一个固定区

  - 存放最活跃的程序段
  - 固定区中的程序段在运行过程中不会调入调出
- 若干个覆盖区

  - 不可能同时被访问程序段可共享一个覆盖区
  - 覆盖区中的程序段在运行过程中会根据需要调入调出
- 必须由程序员声明覆盖结构，操作系统完成自动覆盖
- 缺点

  - 对用户不透明，增加了用户编程负担

### 交换技术

- 内存紧张时，换出某些进程以腾出内存空间，在换入某些进程
- 磁盘分为文件区和对换区，换出的进程放在对换区

### 覆盖与交换的区别

- 覆盖是在同一个程序或进程中的
- 交换是在不同进程（或作业）之间的

## 连续分配管理

### 注

- 为用户进程分区的分配必须是一个连续的内存空间
- 内部碎片

  - 分配给某进程的内存区域中，如果有些部分没有用上
- 外部碎片

  - 值内存中的某些空闲分区由于太小而难以利用

### 单一连续分配

- 只支持单道程序，内存分为系统区和用户区，用户程序放在用户区
- 无外部碎片

### 固定分区分配

- 支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业
- 无外部碎片，有内部碎片
- 两种分区方式

  - 分区大小相等
  - 分区大小不等

### 动态分区分配

- 支持多道程序，在进程装入内存时，根据进程的大小动态地建立分区
- 无外部碎片，有内部碎片
- 外部碎片可用“紧凑”技术来解决
- 回收内存分区时，可能遇到四种情况

  - 回收区之后有相邻的空闲分区
  - 回收区之前有相邻的空闲分区
  - 回收区前，后都有相邻的空闲分区
  - 回收区前，后都没有相邻的空闲分区
- 动态分区分配算法

  - 首次适应算法（First Fit）

    - 算法思想

      - 从头到尾找适合的分区
    - 如何实现

      - 空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。
    - 分区排列顺序

      - 空闲分区以地址递增次序排列
    - 优点

      - 综合看性能最好。算法开销小，回收分区后一般不需要对空闲分区队列重新排序
    - 缺点
  - 最佳适应算法（Best Fit）

    - 算法思想

      - 优先使用更小的分区，以保留更多大分区
    - 如何实现

      - 空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。
    - 分区排列顺序

      - 空闲分区以容量递增次序排列
    - 优点

      - 会有更多的大分区被保留下来，更难满足大进程需求
    - 缺点

      - 会产生很多太小的、难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序
  - 最坏适应算法（Worst Fit）

    - 算法思想

      - 优先使用更大的分区，以防止产生太小的不可用的碎片
    - 如何实现

      - 空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。
    - 分区排列顺序

      - 空闲分区以容量递减次序排列
    - 优点

      - 可以减少难以利用的小小碎片
    - 缺点

      - 大分区容易被用完，不利于大进程；算法开销大（原因同上）
  - 邻近适应算法（Next Fit）

    - 算法思想

      - 由首次适应演变而来，每次从上次查找结束位置开始查找
    - 如何实现

      - 空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表），找到大小能满足要求的第一个空闲分区。
    - 分区排列顺序

      - 空闲分区以地址递增次序排列(可排列成循环链表）
    - 优点

      - 不用每次都从低地址的小分区开始检索。算法开销小（原因同首次适应算法）
    - 缺点

      - 会使高地址的大分区也被用完

## 基本分页存储管理的基本概念

### 基本分页存储管理的思想

- 把进程分页，各个页面可离散地放到各个的内存块中

### 页表

- 页表记录了页面和实际存放的内存块之间的映射的关系
- 一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成
- 每个页表项的大小是相同的，页号是“隐含”的
- i好页表项存放地址 = 页表始址 + i * 页表项大小

### 逻辑地址结构——可拆分为【页号P,页内偏移量W]

- 页号 = 逻辑地址/页面大小；页内偏移量 = 逻辑地址 % 页面大小
- 如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2K个内存单元如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2M个页面

### 如何实现地址转换

- 1.计算出逻辑地址对应的【页号，页内偏移量】
- 2.找到对应页面在内存中的存放位置
- 3.物理地址 = 页面始址 + 页内偏移量

## 变换机构

### 基本地址变换机构

- 页表寄存器的作用

  - 存放页表起始地址
  - 存放页表长度
- 地址变换过程

  - 1.根据逻辑地址算出页号、页内偏移量
  - 2.页号的合法性检查(与页表长度对比)
  - 3.若页号合法，再根据页表起始地址、页号找到对应页表项
  - 4.根据页表项中记录的内存块号、页内偏移量得到最终的物理地址
  - 5.访问物理内存对应的内存单元
- 其它小细节

  - 页内偏移量位数与页面大小之间的关系（要能用其中一个条件推出另一个条件）
  - 页式管理中地址是一维的
  - 实际应用中，通常使一个页框恰好能放入整数个页表项
  - 为了方便找到页表项，页表一般是放在连续的内存块中的
- 访问一个逻辑地址的访存次数

  - 两次访存

### 具有快表的地址变换机构

- 地址变换过程

  - ①算页号、页内偏移量
  - ②检查页号合法性
  - ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤：
  - 若未命中则进行④
  - ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中
  - ⑤根据内存块号与页内偏移量得到物理地址
  - ⑥访问目标内存单元
- 访问一个逻辑地址的访存次数

  - 快表命中，只需一次访存
  - 快表未命中，需要两次访存

### TLB和普通Cache的区别—-TLB中只有页表项的副本，而普通Cache中可能会有其他各种数据的副本

## 两级页表

### 单级页表存在的问题

- 所有页表项必须连续存放，页表过大时需要很大的连续空间
- 在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存

### 两级页表

- 将长长的页表再分页
- 逻辑地址结构：（一级页号，二级页号，页内偏移量）
- 注意几个术语：页目录表/外层页表/顶级页表

### 如何实现地址变换

- ①按照地址结构将逻辑地址拆分成三部分
- ②从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置
- ②根据二级页号查表，找到最终想访问的内存块号
- ⑥结合页内偏移量得到物理地址

### 几个细节

- 多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级
- 多级页表的访存次数（假设没有快表机构）——N级页表访问一个逻辑地址需要N+1次访存

## 基本分段存储管理

### 分段

- 将地址空间按照程序自身的逻辑关系划分为若干个段，每段从0开始编址
- 每个段在内存中占据连续空间，但各段之间可以不相邻
- 逻辑地址结构：（段号，段内地址）

### 段表

- 记录逻辑段到实际存储地址的映射关系
- 每个段对应一个段表项。各段表项长度相同，由段号（隐含）、段长、基址组成

### 地址变换

- 1.由逻辑地址得到段号、段内地址
- 2.段号与段表寄存器中的段长度比较，检查是否越界
- 3.由段表始址、段号找到对应段表项
- 4.根据段表中记录的段长，检查段内地址是否越界
- 5.由段表中的“基址+段内地址"得到最终的物理地址
- 6.访问目标单元

### 分段 VS 分页

- 分页对用户不可见，分段对用户可见
- 分页的地址空间是一维的，分段的地址空间是二维的
- 分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享）
- 分页（单级页表）、分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构

## 分页，分段的优缺点分析

### 分页管理

- 优点

  - 内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片
- 缺点

  - 不方便按照逻辑模块实现信息的共享和保护

### 分段管理

- 优点

  - 很方便按照逻辑模块实现信息的共享和保护
- 缺点

  - 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片

## 段页式管理

### 分段+分页

- 将地址空间按照程序自身的逻辑关系划分为若干个段，在将各段分为大小相等的页面
- 将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存
- 逻辑地址结构：（段号，页号，页内偏移量）

### 段表，页表

- 每个段对应一个段表项。各段表项长度相同，由段号（隐含）、页表长度、页表存放地址组成
- 每个页对应一个页表项。各页表项长度相同，由页号（隐含）、页面存放的内存块号组成

### 地址变换

- 1.由逻辑地址得到段号、页号、页内偏移量
- 2.段号与段表寄存器中的段长度比较，检查是否越界
- 3.由段表始址、段号找到对应段表项
- 4.根据段表中记录的页表长度，检查页号是否越界
- 5.由段表中的页表地址、页号得到查询页表，找到相应页表项
- 6.由页面存放的内存块号、页内偏移量得到最终的物理地址
- 7.访问目标单元

### 访问一个逻辑地址所需访存次数

- 第一次——查段表、第二次——查页表、第三次——访问目标单元
- 可引入快表机构，以段号和页号为关键字查询快表，即可直接找到最终的目标页面存放位置。引入快表后仅需一次访存
