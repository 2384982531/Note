# 处理机调度与死锁

# 处理机调度与死锁

## 处理机调度

### 基本概念

- 按某种算法选择一个进程将处理机分配给它

### 三个层次

- 高级调度（作业调度）

  - 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程
- 中级调度（内存调度）

  - 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存
- 低级调度（进程调度）

  - 按照某种规则，从就绪队列中选择一个进程为其分配处理机

### 三层调度的联系，对比

- 高级调度

  - 发生频率：最低
- 中级调度

  - 发生频率：中等
- 低级调度

  - 发生频率：最高

### 补充知识

- 为减轻系统负载，提高资源利用率，暂时不执行的进程会被调到外存从而变成“挂起态”
- 七状态模型：在五状态模型的基础上加入了“就绪挂起”和“阻塞挂起”两种状态

### 进程调度

- 时机

  - 什么时候需要进程调度？

    - 主动放弃

      - 进程正常终止
      - 运行过程中发生异常
      - 主动阻塞（如 等待I/O)
    - 被动放弃

      - 分给进程的时间片用完
      - 有更紧急的事情需要处理（如I/O中断）
      - 有更优先级的进程进入就绪队列
  - 什么时候不能进行进程调度？

    - 在处理中断的过程中
    - 进程在操作系统内核程序临界区中
    - 原子操作过程中（原语）
- 切换与过程

  - 狭义的“调度”和切换的区别
  - 切换过程

    - 对原来运行进程各种数据的保存
    - 对新的进程各种数据的恢复
  - 重要结论：进程调度，切换是有代价的，并不是调度越频繁，并发度就越高
- 方式

  - 非剥夺调度方式（非抢占式）

    - 只能由当前运行的进程主动放弃CPU
  - 剥夺调度方式（抢占式）

    - 可由操作系统剥夺当前进程的CPU使用权
- 其它

  - 临界资源

    - 一个时间段内只允许一个进程使用的资源
  - 临界区

    - 访问临界资源的那段代码
  - 内核程序临界区

    - 一般是用来访问某种内核数据结构的

### 调度算法的评价指标

- CPU利用率
- 系统吞吐量
- 周转时间
- 等待时间

  - 进程/作业 等待被服务的时间之和
  - 平均等待时间即各个进程/作业等待时间的平均值
- 响应时间

  - 从用户提交请求到首次产生响应所用的时间

## 调度算法

### 先来先服务（FCFS）

- 算法思想

  - 主要从“公平”的角度考虑，类似排队买东西
- 算法规则

  - 按照作业/进程到达的先后顺序进行服务
- 用于作业/进程调度

  - 用于作业调度时，考虑的是那个作业先到达后备队列
  - 用于进程调度时，考虑的是那个进程先到达就绪队列
- 是否可抢占

  - 非抢占式的算法
- 优缺点

  - 优点

    - 公平，算法实现简单
  - 缺点

    - 排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验感不好，既FCFS算法对长作业有利，对短作业不利
- 是否会导致饥饿

  - 不会

### 短作业优先（SJF）

- 算法思想

  - 追求最少的平均周转时间，最少的平均周转时间，最少的平均带权周转时间
- 算法规则

  - 最短的作业/进程优先得到服务（要求服务时间最短，在服务时间相同时，看到达先后顺序）
- 用于作业/进程调度

  - 即可用于作业调度，也可用于进程调度。用于进程调度时称为“短作业优先”（SPF）
- 是否可抢占？

  - SJF和SPF都是非抢占式的算法，但是也有抢占式的版本--最短剩余时间优先算法（SRTN）
- 优缺点

  - 优点

    - “最短的”平均等待时间，平均周转时间
  - 缺点

    - 不公平。对短作业有利，对长作业不利，可能产生饥饿现象。另外，作业/进程的运行时间是有用户提供的，并不一定真实，不一定做到真正的短作业优先
- 是否会导致饥饿

  - 会。如果源源不断的有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”

### 最短剩余时间优先算法

- 最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度

### HRRN（高响应比优先HRRN）

- 算法思想

  - 要考虑作业/进程的等待时间
- 算法规则

  - 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务
- 用于作业/进程调度

  - 即可用于作业调度，也可用于进程调度
- 是否可抢占

  - 非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理技时，才需要调度，才需要计算响应比
- 优缺点

  - 综合考虑了等待时间和运行时间（要求服务时间)
    等待时间相同时，要求服务时间短的优先(SJF的优点)
    要求服务时间相同时，等待时间长的优先（FCFS的优点)
    对于长作业来说，随着等待时间越来越久，其响应比也会
    越来越大，从而避免了长作业饥饿的问题
- 是否会导致饥饿

  - 不会
- 响应比

  - （等待时间+要求服务时间）/要求服务时间
  - 等待时间=开始执行时间-进入时间

### RR（时间片轮转）

- 算法思想

  - 公平地，轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
- 算法规则

  - 按照各进程到达就绪队列的 顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新到就绪队列队尾重新排队
- 用于作业/进程调度

  - 用于进程 调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）
- 是否可抢占？

  - 若进程未能在时间 片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到
- 优缺点

  - 优点

    - 公平，响应快 ，适用于分时操作系统
  - 缺点

    - 由于高频繁的进程切换，因此有一定开销；不区分任务的紧急程度
- 是否会导致饥饿

  - 不会
- 一般来说，设计 时间片时要让切换进程的开销占比不超过1%

### 优先级调度算法

- 算法思想

  - 随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序
- 算法规则

  - 每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程
- 用于作业/进程调度

  - 即可用于作业调度，也可用于进程调度。甚至，还会 用于 在之后会学习的I/O调度中
- 是否可抢占？

  - 抢占式，非抢占 式都有。做题时区别在与：非抢占式只需在进程主动放弃处理机时进行调度即可，抢占式还需在就绪队列变化时，检查是否会发生抢占
- 优缺点？

  - 优点

    - 抢占式，非抢占式都有。做题时的区别在与：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占时还需在就绪队列 变化时，检查是否会发生抢占
- 是否会导致饥饿

  - 会
- 优先级

  - 静态优先级

    - 创建进程时确定，之后一直不变
  - 动态优先级

    - 创建进程时有一个初始值，之后会根据情况动态地调整优先级
  - 通常

    - 系统进程优先级高于用户进程
    - 前台进程 优先级高于后台进程
    - 操作系统更偏好I/O型进程（或称I/O繁忙型 进程）
    - 与I/O型进程 相对的是计算型进程（或称 CPU繁忙型进程）

### 多级反馈队列调度算法

- 算法思想

  - 对其他调度算法的折中权衡
- 算法规则

  - 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
  - 新进程到达时先进入第1级队列，按FCFS原则等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾
  - 只有第k级队列为空时，才会为k+1级对头的进程分配 时间片
- 用于作业/进程调度

  - 用于进程调度
- 是否可抢占？

  - 抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个 新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾
- 优缺点

  - 对各类型进程相对公平（FCFS的优点）：每个新到达的进程都可以很快就得到响应(RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、l/O密集型进程(拓展：可以将因I/0而阻塞的进程重新放回原队列，这样1/0型进程就可以保持较高优先级）
- 是否会导致饥饿

  - 会

## 实时调度

### 实时系统

- 定义

  - 时间和功能两方面的一种操作系统
- 性能指标

  - 时间约束的及时性
  - 速度和平均性能相对不重要
- 主要特性

  - 时间约束的可预测性

### 实时任务

- 具有明确时间约束的计算任务
- 分类

  - 强实时系统

    - 需要在保证的时间内完成重要的任务，必须完成
  - 弱实时系统

    - 要求重要的进程 的优先级更高，尽量完成，非必须
- 类型

  - 周期性

    - 每隔固定时间发生一次
  - 随机性

    - 由随机事件触发，其发生时刻不确定

### 实时调度

- 合理安排就绪实时任务的执行次序，满足每个实时任务时间约束条件的调度

### 术语

- 就绪时间
- 开始截止期

  - 实时任务最迟开始处理的时间
- 处理时间

  - 实时任务所需处理机处理的时间
- 完成截止期

  - 实时任务最迟完成的时间
- 发生周期

  - 周期性实时任务的发生间隔 时间
- 发生频率

### EDF（最早截止期优先调度）

- 优先选择截止期最早的实时任务
- 可抢先
- 可调度的充分条件
- 在不可调度的条件下，可使错过截止期任务最小化

### RMS（速率单调调度算法）

- 面向周期性实时事务，非剥夺式
- 优先调度发生周期最短（频度最高）的实时任务
- 可调度条件

  - n是任务数

### LLF（最低松弛度优先算法Least Laxity First）

- 定义

  - 根据任务的紧急（松弛度）程度来确定任务的优先级的算法，任务紧急程度愈高，其优先级就愈高
- 可抢占式
- 任务松弛度计算公式

## 死锁

### 死锁的概念

- 什么是死锁

  - 各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进
- 进程死锁，饥饿，死循环的区别

  - 死锁

    - 至少是两个进程一起死锁，死锁进程处于阻塞态
  - 饥饿

    - 可以只有一个进程饥饿，饥饿进程可能阻塞也可能就绪
  - 死循环

    - 可能只有一个进程发生死循环，死循环的进程可上处理机
  - 死锁和饥饿是操作系统要解决的问题，死循环是应用 程序员要解决的
- 死锁产生的必要条件

  - 互斥条件

    - 对必须互斥使用的资源的争抢才会导致死锁
  - 不剥夺条件

    - 进程保持的资源只能主动释放，不可强行剥夺
  - 请求和保持条件

    - 保持着某些资源不放的同时，请求别的资源
  - 循环等待条件

    - 存在一种进程资源的循环等待链
    - 循环等待未必死锁，死锁一定有循环等待
- 什么时候会发生死锁

  - 对不可剥夺资源的不合理分配，可能导致死锁
- 死锁的处理策略

  - 预防死锁

    - 破坏死锁产生的四个必要条件
  - 避免死锁

    - 避免系统进入不安全状态（银行间算法）
  - 死锁的检测和解除

    - 允许死锁发生，系统负责检测出死锁并解除

### 死锁的处理

- 不允许死锁发生

  - 静态策略：预防死锁

    - 破坏互斥条件
    - 破坏不剥夺条件
    - 破坏请求和保持条件
    - 破坏循环等待条件
  - 动态策略：避免死锁
- 允许死锁发生

  - 死锁的检测和解除

### 预防死锁

- 破坏互斥条件

  - 将临界资源改造为可共享使用的资源（如SPOOLing技术）
  - 缺点：可行性不高，很多时候无法破坏互斥条件
- 破坏不剥夺条件

  - 方案一：申请的资源得不到满足时，立即释放拥有的所有资源
  - 方案二：申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级）
  - 缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿
- 破坏请求和保持条件

  - 运行前分配好所有需要的资源，之后一直保持
  - 缺点：资源利用率低 ；可能导致饥饿
- 破坏循环等待条件

  - 给资源编号，必须按编号从小到大的顺序申请资源
  - 缺点：不方便增加新设备；会导致资源浪费；用户编程麻烦

### 死锁的检测和解除

- 如何检测

  - 数据结构：资源分配图

    - 两种结点

      - 进程结点
      - 资源结点
    - 两种边

      - 表示进程想申请几个资源 (每条边代表一个)

      - 表示已经为进程分配了几个资源 (每条边代表一个)
  - 死锁检测算法

    - 依次消除与不阻塞进程相连的边，直到无边可销，还连着边的那些进程就是死锁进程
    - 注：所谓不阻塞进程是指其申请的资源数还不足够的进程
    - 死锁定理：看资源分配图是不可完全简化的，说明发生了死锁
- 如何解除

  - 资源剥夺法

    - 挂起(暂时放到外存上)某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
  - 撤销进程法（终止进程法）

    - 强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一第，以后还得从头再来。
  - 进程回退法

    - 让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。
