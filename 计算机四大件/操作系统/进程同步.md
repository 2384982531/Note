# 进程同步

# 进程同步

## 同步与互斥

### 进程同步

- 并发性带来了异步性，有时需要通过进程同步解决这种异步问题。有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序

### 进程互斥

- 对临界资源的访问，需要互斥的进行。即同一时间内只能  允许 一个进程访问该资源
- 四个部分

  - 进入区

    - 检查是否可进入临界区，若可进入，需要 “上锁”
  - 临界区

    - 访问临界资源的那段代码
  - 退出区

    - 负责解锁
  - 剩余区

    - 其余代码部分
- 需要遵循的原则

  - 空闲让进

    - 临界区空闲时，应允许一个进程访问
  - 忙则等待

    - 临界区正在被访问时，其他试图访问的进程需要等待
  - 有限等待

    - 要在有限时间内进入临界区 ，保证不会饥饿
  - 让权等待

    - 进不了临界区的进程，要释放处理机，防止 忙等

## 进程互斥的软件实现方法

### 单标志法

- 算法思想

  - 两个进程在访问临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进入 临界区的权限只能被另一个进程赋予
- 在进入区只做“检查”，不“上锁”
- 在退出区把临界区的使用权转 交给另一个进程（相当于在退出区即给另一进程“解锁”，又给自己“上锁”）
- 主要问题

  - 不遵循空闲让进”原则

### 双标志先检查

- 算法思想

  - 设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[O]=ture”意味着o号进程Po现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,如果没有，则把自身对应的标志flagli] 设为true,之后开始访问临界区。
- 在进入区先“检查”后“上锁”，退出区“解锁”
- 主要问题

  - 不遵循"忙则等待"原则

### 双标志后检查

- 算法思想

  - 双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。
- 在进入区先“加锁”后“检查”，退出区“解锁"
- 主要问题

  - 不遵循“空闲让进，有限等待”原则，可能导致“饥饿”

### Peterson算法

- 算法思想

  - 双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L.Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区。
- 在进入区“主动争取——主动谦让——检查对方是否想进，己方是否谦让”
- 主要问题

  - 不遵循“让权等待”原则，会发生“忙等”

## 进程互斥的硬件实现方法

### 中断屏蔽方法

- 使用“开/关中断”指令实现
- 优点

  - 简单高效
- 缺点

  - 只适用于单处理机；只适用于操作系统内核进程

### TestAndSet（TS指令/TSL指令）

- old记录是否已被上锁；在将lock设为true；检查 临界区是否已被上锁（若已上锁，则循环重复前几步）
- 优点

  - 实现简单
  - 适用于多处理机环境
- 缺点

  - 不满足“让权等待”

### Swap指令 （XCHG指令）

- old记录是否已被上锁；在将lock设为true；检查 临界区是否已被上锁（若已上锁，则循环重复前几步）

## 信号量机制

### 整型信号量

- 用一个整数型变量作为信号量，数值表示某种资源数
- 整型信号量与普通整型变量的区别

  - 对信号量只能执行初始化，P，V三种操作
- 整型信号量存在的问题

  - 不满足让权等待原则

### 记录型信号量

- S.value表示某种资源数，S.L 指向等待该资源的队列
- P操作中，一定是先S.value--，之后可能需要执行block原语
- V操作中，一定是先S.value++，之后可能需要执行wakeup原语
- 注意：要能够自己推断在什么条件下需要执行block或wakeup
- 可以用记录型信号量实现系统资源的“申请”和“释放”
- 可以用记录型信号量实现进程互斥，进程同步

### 实现进程互斥

- 分析问题，确定临界区
- 设置互斥信号量，初值为1
- 临界区之前对信号量执行P操作
- 临界区之后对信号量执行V操作

### 实现进程同步

- 分析问题，找出哪里需要实现“一前一后”的同步关系
- 设置同步信号量，初始值为0
- 在“前操作”之后执行V操作
- 在“后操作”之前执行P操作

### 实现进程的前驱关系

- 分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题
- 为每一对前驱关系设置同步信号量，初值为0
- 在每个“前操作”之后执行V操作
- 在每个“后操作”之前执行P操作
